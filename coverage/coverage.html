
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v3: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/menta2k/protoc-gen-redact/v3/errors.go (24.5%)</option>
				
				<option value="file1">github.com/menta2k/protoc-gen-redact/v3/examples/tests/message.pb.go (0.0%)</option>
				
				<option value="file2">github.com/menta2k/protoc-gen-redact/v3/examples/tests/message.pb.redact.go (0.0%)</option>
				
				<option value="file3">github.com/menta2k/protoc-gen-redact/v3/fields.go (21.5%)</option>
				
				<option value="file4">github.com/menta2k/protoc-gen-redact/v3/imports.go (0.0%)</option>
				
				<option value="file5">github.com/menta2k/protoc-gen-redact/v3/main.go (0.0%)</option>
				
				<option value="file6">github.com/menta2k/protoc-gen-redact/v3/module.go (16.7%)</option>
				
				<option value="file7">github.com/menta2k/protoc-gen-redact/v3/process.go (0.0%)</option>
				
				<option value="file8">github.com/menta2k/protoc-gen-redact/v3/redact/v3/interface.go (0.0%)</option>
				
				<option value="file9">github.com/menta2k/protoc-gen-redact/v3/redact/v3/redact.pb.go (0.0%)</option>
				
				<option value="file10">github.com/menta2k/protoc-gen-redact/v3/utils.go (96.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"

        pgs "github.com/lyft/protoc-gen-star/v2"
        "google.golang.org/grpc/codes"

        "github.com/menta2k/protoc-gen-redact/v3/redact/v3"
)

// ErrorContext provides additional context for errors
type ErrorContext struct {
        Location string
        Field    string
        Type     string
        Rule     string
        Reason   string
}

// Error returns a formatted error message with context
func (e ErrorContext) Error() string <span class="cov5" title="6">{
        if e.Location != "" &amp;&amp; e.Field != "" </span><span class="cov2" title="2">{
                return fmt.Sprintf("[%s.%s] %s", e.Location, e.Field, e.Reason)
        }</span>
        <span class="cov4" title="4">if e.Location != "" </span><span class="cov3" title="3">{
                return fmt.Sprintf("[%s] %s", e.Location, e.Reason)
        }</span>
        <span class="cov1" title="1">return e.Reason</span>
}

// ValidationError represents a validation error with detailed context
type ValidationError struct {
        Entity   string
        Expected string
        Got      string
        Hint     string
}

// Error returns a formatted validation error message
func (v ValidationError) Error() string <span class="cov5" title="5">{
        msg := fmt.Sprintf("Validation failed for %s", v.Entity)
        if v.Expected != "" </span><span class="cov4" title="4">{
                msg += fmt.Sprintf(": expected %s", v.Expected)
        }</span>
        <span class="cov5" title="5">if v.Got != "" </span><span class="cov4" title="4">{
                msg += fmt.Sprintf(", got %s", v.Got)
        }</span>
        <span class="cov5" title="5">if v.Hint != "" </span><span class="cov4" title="4">{
                msg += fmt.Sprintf(" (hint: %s)", v.Hint)
        }</span>
        <span class="cov5" title="5">return msg</span>
}

// must wraps error checking with improved error messages
func (m *Module) must(ok bool, err error) bool <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                m.Fail(err)
        }</span>
        <span class="cov0" title="0">return ok</span>
}

// mustNotNil checks if a value is not nil and fails with context if it is
func (m *Module) mustNotNil(value interface{}, context string) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                m.Failf("Unexpected nil value: %s", context)
        }</span>
}

// validateField performs comprehensive field validation
func (m *Module) validateField(field pgs.Field) error <span class="cov0" title="0">{
        if field == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("field is nil")
        }</span>

        <span class="cov0" title="0">typ := field.Type()
        if typ == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("field %s has nil type", field.Name())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateMessage performs comprehensive message validation
func (m *Module) validateMessage(msg pgs.Message) error <span class="cov0" title="0">{
        if msg == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("message is nil")
        }</span>

        // Check for conflicting options
        <span class="cov0" title="0">ignore := false
        toNil := false
        toEmpty := false

        m.must(msg.Extension(redact.E_Ignored, &amp;ignore))
        m.must(msg.Extension(redact.E_Nil, &amp;toNil))
        m.must(msg.Extension(redact.E_Empty, &amp;toEmpty))

        conflictCount := 0
        if ignore </span><span class="cov0" title="0">{
                conflictCount++
        }</span>
        <span class="cov0" title="0">if toNil </span><span class="cov0" title="0">{
                conflictCount++
        }</span>
        <span class="cov0" title="0">if toEmpty </span><span class="cov0" title="0">{
                conflictCount++
        }</span>

        <span class="cov0" title="0">if conflictCount &gt; 1 </span><span class="cov0" title="0">{
                return ValidationError{
                        Entity:   fmt.Sprintf("message %s", msg.FullyQualifiedName()),
                        Expected: "at most one of (redact.ignored), (redact.nil), or (redact.empty)",
                        Got:      fmt.Sprintf("multiple options set (ignored=%v, nil=%v, empty=%v)", ignore, toNil, toEmpty),
                        Hint:     "these options are mutually exclusive",
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateService performs comprehensive service validation
func (m *Module) validateService(srv pgs.Service) error <span class="cov0" title="0">{
        if srv == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service is nil")
        }</span>

        // Validate internal service status code
        <span class="cov0" title="0">srvCode := uint32(codes.PermissionDenied)
        if m.must(srv.Extension(redact.E_InternalServiceCode, &amp;srvCode)) </span><span class="cov0" title="0">{
                if err := m.validateStatusCode(srvCode, srv.FullyQualifiedName()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateMethod performs comprehensive method validation
func (m *Module) validateMethod(meth pgs.Method) error <span class="cov0" title="0">{
        if meth == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("method is nil")
        }</span>

        <span class="cov0" title="0">if meth.Input() == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("method %s has nil input", meth.Name())
        }</span>

        <span class="cov0" title="0">if meth.Output() == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("method %s has nil output", meth.Name())
        }</span>

        // Validate internal method status code
        <span class="cov0" title="0">methCode := uint32(codes.PermissionDenied)
        if m.must(meth.Extension(redact.E_InternalMethodCode, &amp;methCode)) </span><span class="cov0" title="0">{
                if err := m.validateStatusCode(methCode, meth.FullyQualifiedName()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateStatusCode validates a gRPC status code
func (m *Module) validateStatusCode(code uint32, location string) error <span class="cov9" title="27">{
        if code &gt; uint32(codes.Unauthenticated) </span><span class="cov6" title="7">{ // 16
                return ValidationError{
                        Entity:   fmt.Sprintf("status code in %s", location),
                        Expected: "valid gRPC status code (0-16)",
                        Got:      fmt.Sprintf("%d", code),
                        Hint:     "see https://grpc.io/docs/guides/status-codes/ for valid codes",
                }
        }</span>
        <span class="cov8" title="20">return nil</span>
}

// validateTypeMatch validates that a field type matches a rule type
func (m *Module) validateTypeMatch(
        field pgs.Field,
        ruleType pgs.ProtoType,
        ruleLabel pgs.ProtoLabel,
) error <span class="cov0" title="0">{
        fieldType := field.Type()

        // Check type match
        if ruleType != 0 &amp;&amp; ruleType != fieldType.ProtoType() </span><span class="cov0" title="0">{
                return ValidationError{
                        Entity:   fmt.Sprintf("field %s", field.FullyQualifiedName()),
                        Expected: fmt.Sprintf("rule for type %s", fieldType.ProtoType()),
                        Got:      fmt.Sprintf("rule for type %s", ruleType),
                        Hint:     fmt.Sprintf("use %s instead", ToCustomRule(fieldType.ProtoType(), fieldType.ProtoLabel())),
                }
        }</span>

        // Check label match for repeated fields
        <span class="cov0" title="0">if fieldType.ProtoLabel() == pgs.Repeated &amp;&amp; ruleLabel != pgs.Repeated </span><span class="cov0" title="0">{
                return ValidationError{
                        Entity:   fmt.Sprintf("repeated field %s", field.FullyQualifiedName()),
                        Expected: "(redact.custom).element.*",
                        Got:      "non-repeated rule",
                        Hint:     "repeated fields require element rules",
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// failWithInvalidType generates an error for type mismatch with helpful suggestions
func (m *Module) failWithInvalidType(field pgs.Field) <span class="cov0" title="0">{
        typ := field.Type()
        want := ToCustomRule(typ.ProtoType(), typ.ProtoLabel())

        err := ValidationError{
                Entity:   field.FullyQualifiedName(),
                Expected: want,
                Got:      "incompatible redaction rule type",
                Hint:     fmt.Sprintf("ensure the rule type matches the field type (%s)", typ.ProtoType()),
        }

        m.Fail(err)
}</span>

// failWithContext fails with additional contextual information
func (m *Module) failWithContext(field pgs.Field, reason string) <span class="cov0" title="0">{
        err := ErrorContext{
                Location: field.Message().FullyQualifiedName(),
                Field:    field.Name().String(),
                Type:     field.Type().ProtoType().String(),
                Reason:   reason,
        }
        m.Fail(err)
}</span>

// failWithNestedError fails when nested element rules are incorrectly used
func (m *Module) failWithNestedError(field pgs.Field) <span class="cov0" title="0">{
        err := ErrorContext{
                Location: field.Message().FullyQualifiedName(),
                Field:    field.Name().String(),
                Type:     field.Type().ProtoType().String(),
                Reason:   "nested element.item.element... is not supported - maximum nesting depth is 1",
        }
        m.Failf("%s\n\nHint: Use either:\n  - (redact.custom).element.nested for iteration\n  - (redact.custom).element.item.* for custom item values\n  - (redact.custom).element.empty for empty list", err.Error())
}</span>

// warnDeprecated logs a deprecation warning
func (m *Module) warnDeprecated(feature, alternative string) <span class="cov0" title="0">{
        m.Debug(fmt.Sprintf("DEPRECATED: %s is deprecated, use %s instead", feature, alternative))
}</span>

// validateFile performs file-level validation
func (m *Module) validateFile(file pgs.File) error <span class="cov0" title="0">{
        if file == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("file is nil")
        }</span>

        <span class="cov0" title="0">if file.Package() == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("file %s has no package", file.Name())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateRules validates FieldRules for correctness
func (m *Module) validateRules(rules *redact.FieldRules, field pgs.Field) error <span class="cov0" title="0">{
        if rules == nil </span><span class="cov0" title="0">{
                return nil // No rules is valid
        }</span>

        <span class="cov0" title="0">if rules.Values == nil </span><span class="cov0" title="0">{
                return ValidationError{
                        Entity:   field.FullyQualifiedName(),
                        Expected: "redaction rule with values",
                        Got:      "empty rule",
                        Hint:     "define a value for the custom redaction rule",
                }
        }</span>

        // Validate message rules
        <span class="cov0" title="0">if msgRule, ok := rules.Values.(*redact.FieldRules_Message); ok </span><span class="cov0" title="0">{
                if msgRule.Message == nil </span><span class="cov0" title="0">{
                        return ValidationError{
                                Entity:   field.FullyQualifiedName(),
                                Expected: "message rule definition",
                                Got:      "nil message rule",
                                Hint:     "use (redact.custom).message.nil, .empty, or .skip",
                        }
                }</span>
        }

        // Validate element rules
        <span class="cov0" title="0">if elemRule, ok := rules.Values.(*redact.FieldRules_Element); ok </span><span class="cov0" title="0">{
                if elemRule.Element == nil </span><span class="cov0" title="0">{
                        return ValidationError{
                                Entity:   field.FullyQualifiedName(),
                                Expected: "element rule definition",
                                Got:      "nil element rule",
                                Hint:     "use (redact.custom).element.nested, .empty, or .item.*",
                        }
                }</span>

                // Check for invalid nested element rules
                <span class="cov0" title="0">if elemRule.Element.Item != nil &amp;&amp; elemRule.Element.Item.Values != nil </span><span class="cov0" title="0">{
                        if _, ok := elemRule.Element.Item.Values.(*redact.FieldRules_Element); ok </span><span class="cov0" title="0">{
                                return ValidationError{
                                        Entity:   field.FullyQualifiedName(),
                                        Expected: "single-level element nesting",
                                        Got:      "element.item.element",
                                        Hint:     "nested element rules are not supported",
                                }
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// recoverFromPanic recovers from panics and converts them to errors
func (m *Module) recoverFromPanic(context string) <span class="cov0" title="0">{
        if r := recover(); r != nil </span><span class="cov0" title="0">{
                m.Failf("Panic in %s: %v", context, r)
        }</span>
}

// validateImportPath validates an import path
func (m *Module) validateImportPath(path string) error <span class="cov5" title="5">{
        if path == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("import path is empty")
        }</span>

        // Basic validation - can be extended
        <span class="cov4" title="4">if len(path) &gt; 1000 </span><span class="cov1" title="1">{
                return fmt.Errorf("import path too long: %d characters", len(path))
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// validatePackageName validates a package name
func (m *Module) validatePackageName(name string) error <span class="cov5" title="6">{
        if name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("package name is empty")
        }</span>

        // Check for invalid characters (basic validation)
        <span class="cov5" title="5">for i, c := range name </span><span class="cov10" title="33">{
                if i == 0 &amp;&amp; c &gt;= '0' &amp;&amp; c &lt;= '9' </span><span class="cov1" title="1">{
                        return ValidationError{
                                Entity:   "package name",
                                Expected: "identifier starting with letter or underscore",
                                Got:      fmt.Sprintf("name starting with digit: %s", name),
                                Hint:     "package names cannot start with numbers",
                        }
                }</span>
        }

        <span class="cov4" title="4">return nil</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.33.0
//         protoc        v5.26.1
// source: examples/tests/message.proto

package tests

import (
        reflect "reflect"
        sync "sync"

        _ "github.com/menta2k/protoc-gen-redact/v3/redact/v3"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TestEnum int32

const (
        TestEnum_ValueZero TestEnum = 0
        TestEnum_ValueOne  TestEnum = 1
        TestEnum_ValueTwo  TestEnum = 2
)

// Enum value maps for TestEnum.
var (
        TestEnum_name = map[int32]string{
                0: "ValueZero",
                1: "ValueOne",
                2: "ValueTwo",
        }
        TestEnum_value = map[string]int32{
                "ValueZero": 0,
                "ValueOne":  1,
                "ValueTwo":  2,
        }
)

func (x TestEnum) Enum() *TestEnum <span class="cov0" title="0">{
        p := new(TestEnum)
        *p = x
        return p
}</span>

func (x TestEnum) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TestEnum) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_examples_tests_message_proto_enumTypes[0].Descriptor()
}</span>

func (TestEnum) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_examples_tests_message_proto_enumTypes[0]
}</span>

func (x TestEnum) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TestEnum.Descriptor instead.
func (TestEnum) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_examples_tests_message_proto_rawDescGZIP(), []int{0}
}</span>

type TestMessage struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FloatValue    float32                   `protobuf:"fixed32,2,opt,name=float_value,json=floatValue,proto3" json:"float_value,omitempty"`
        DoubleValue   float64                   `protobuf:"fixed64,4,opt,name=double_value,json=doubleValue,proto3" json:"double_value,omitempty"`
        Int32Value    int32                     `protobuf:"varint,6,opt,name=int32_value,json=int32Value,proto3" json:"int32_value,omitempty"`
        Int64Value    int64                     `protobuf:"varint,8,opt,name=int64_value,json=int64Value,proto3" json:"int64_value,omitempty"`
        Uint32Value   uint32                    `protobuf:"varint,10,opt,name=uint32_value,json=uint32Value,proto3" json:"uint32_value,omitempty"`
        Uint64Value   uint64                    `protobuf:"varint,12,opt,name=uint64_value,json=uint64Value,proto3" json:"uint64_value,omitempty"`
        Sint32Value   int32                     `protobuf:"zigzag32,14,opt,name=sint32_value,json=sint32Value,proto3" json:"sint32_value,omitempty"`
        Sint64Value   int64                     `protobuf:"zigzag64,16,opt,name=sint64_value,json=sint64Value,proto3" json:"sint64_value,omitempty"`
        Fixed32Value  uint32                    `protobuf:"fixed32,18,opt,name=fixed32_value,json=fixed32Value,proto3" json:"fixed32_value,omitempty"`
        Fixed64Value  uint64                    `protobuf:"fixed64,20,opt,name=fixed64_value,json=fixed64Value,proto3" json:"fixed64_value,omitempty"`
        Sfixed32Value int32                     `protobuf:"fixed32,22,opt,name=sfixed32_value,json=sfixed32Value,proto3" json:"sfixed32_value,omitempty"`
        Sfixed64Value int64                     `protobuf:"fixed64,24,opt,name=sfixed64_value,json=sfixed64Value,proto3" json:"sfixed64_value,omitempty"`
        BoolValue     bool                      `protobuf:"varint,26,opt,name=bool_value,json=boolValue,proto3" json:"bool_value,omitempty"`
        StringValue   string                    `protobuf:"bytes,28,opt,name=string_value,json=stringValue,proto3" json:"string_value,omitempty"`
        BytesValue    []byte                    `protobuf:"bytes,30,opt,name=bytes_value,json=bytesValue,proto3" json:"bytes_value,omitempty"`
        EnumValue     TestEnum                  `protobuf:"varint,32,opt,name=enum_value,json=enumValue,proto3,enum=tests.TestEnum" json:"enum_value,omitempty"`
        MessageNil    *TestMessage              `protobuf:"bytes,34,opt,name=message_nil,json=messageNil,proto3" json:"message_nil,omitempty"`
        MessageSkip   *TestMessage              `protobuf:"bytes,35,opt,name=message_skip,json=messageSkip,proto3" json:"message_skip,omitempty"`
        MessageEmpty  *TestMessage              `protobuf:"bytes,36,opt,name=message_empty,json=messageEmpty,proto3" json:"message_empty,omitempty"`
        Map1Empty     map[int64]string          `protobuf:"bytes,39,rep,name=map1_empty,json=map1Empty,proto3" json:"map1_empty,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Map2Empty     map[string]*emptypb.Empty `protobuf:"bytes,40,rep,name=map2_empty,json=map2Empty,proto3" json:"map2_empty,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Map1Nested    map[int64]string          `protobuf:"bytes,41,rep,name=map1_nested,json=map1Nested,proto3" json:"map1_nested,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Map2Nested    map[string]*emptypb.Empty `protobuf:"bytes,42,rep,name=map2_nested,json=map2Nested,proto3" json:"map2_nested,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Map1Item      map[int64]string          `protobuf:"bytes,43,rep,name=map1_item,json=map1Item,proto3" json:"map1_item,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Map2ItemNil   map[string]*emptypb.Empty `protobuf:"bytes,44,rep,name=map2_item_nil,json=map2ItemNil,proto3" json:"map2_item_nil,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Map2ItemSkip  map[string]*emptypb.Empty `protobuf:"bytes,45,rep,name=map2_item_skip,json=map2ItemSkip,proto3" json:"map2_item_skip,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Map2ItemEmpty map[string]*emptypb.Empty `protobuf:"bytes,46,rep,name=map2_item_empty,json=map2ItemEmpty,proto3" json:"map2_item_empty,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *TestMessage) Reset() <span class="cov0" title="0">{
        *x = TestMessage{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_examples_tests_message_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TestMessage) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TestMessage) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TestMessage) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_examples_tests_message_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TestMessage.ProtoReflect.Descriptor instead.
func (*TestMessage) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_examples_tests_message_proto_rawDescGZIP(), []int{0}
}</span>

func (x *TestMessage) GetFloatValue() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FloatValue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetDoubleValue() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DoubleValue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetInt32Value() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Int32Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetInt64Value() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Int64Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetUint32Value() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uint32Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetUint64Value() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uint64Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetSint32Value() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sint32Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetSint64Value() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sint64Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetFixed32Value() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fixed32Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetFixed64Value() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fixed64Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetSfixed32Value() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sfixed32Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetSfixed64Value() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sfixed64Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TestMessage) GetBoolValue() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BoolValue
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TestMessage) GetStringValue() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StringValue
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TestMessage) GetBytesValue() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BytesValue
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetEnumValue() TestEnum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EnumValue
        }</span>
        <span class="cov0" title="0">return TestEnum_ValueZero</span>
}

func (x *TestMessage) GetMessageNil() *TestMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageNil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMessageSkip() *TestMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageSkip
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMessageEmpty() *TestMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageEmpty
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMap1Empty() map[int64]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Map1Empty
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMap2Empty() map[string]*emptypb.Empty <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Map2Empty
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMap1Nested() map[int64]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Map1Nested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMap2Nested() map[string]*emptypb.Empty <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Map2Nested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMap1Item() map[int64]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Map1Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMap2ItemNil() map[string]*emptypb.Empty <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Map2ItemNil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMap2ItemSkip() map[string]*emptypb.Empty <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Map2ItemSkip
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TestMessage) GetMap2ItemEmpty() map[string]*emptypb.Empty <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Map2ItemEmpty
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RepeatedM struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FloatValueEmpties    []float32      `protobuf:"fixed32,2,rep,packed,name=float_value_empties,json=floatValueEmpties,proto3" json:"float_value_empties,omitempty"`
        FloatValueNested     []float32      `protobuf:"fixed32,3,rep,packed,name=float_value_nested,json=floatValueNested,proto3" json:"float_value_nested,omitempty"`
        FloatValues          []float32      `protobuf:"fixed32,4,rep,packed,name=float_values,json=floatValues,proto3" json:"float_values,omitempty"`
        DoubleValueEmpties   []float64      `protobuf:"fixed64,6,rep,packed,name=double_value_empties,json=doubleValueEmpties,proto3" json:"double_value_empties,omitempty"`
        DoubleValueNested    []float64      `protobuf:"fixed64,7,rep,packed,name=double_value_nested,json=doubleValueNested,proto3" json:"double_value_nested,omitempty"`
        DoubleValues         []float64      `protobuf:"fixed64,8,rep,packed,name=double_values,json=doubleValues,proto3" json:"double_values,omitempty"`
        Int32ValueEmpties    []int32        `protobuf:"varint,10,rep,packed,name=int32_value_empties,json=int32ValueEmpties,proto3" json:"int32_value_empties,omitempty"`
        Int32ValueNested     []int32        `protobuf:"varint,11,rep,packed,name=int32_value_nested,json=int32ValueNested,proto3" json:"int32_value_nested,omitempty"`
        Int32Values          []int32        `protobuf:"varint,12,rep,packed,name=int32_values,json=int32Values,proto3" json:"int32_values,omitempty"`
        Int64ValueEmpties    []int64        `protobuf:"varint,14,rep,packed,name=int64_value_empties,json=int64ValueEmpties,proto3" json:"int64_value_empties,omitempty"`
        Int64ValueNested     []int64        `protobuf:"varint,15,rep,packed,name=int64_value_nested,json=int64ValueNested,proto3" json:"int64_value_nested,omitempty"`
        Int64Values          []int64        `protobuf:"varint,16,rep,packed,name=int64_values,json=int64Values,proto3" json:"int64_values,omitempty"`
        Uint32ValueEmpties   []uint32       `protobuf:"varint,18,rep,packed,name=uint32_value_empties,json=uint32ValueEmpties,proto3" json:"uint32_value_empties,omitempty"`
        Uint32ValueNested    []uint32       `protobuf:"varint,19,rep,packed,name=uint32_value_nested,json=uint32ValueNested,proto3" json:"uint32_value_nested,omitempty"`
        Uint32Values         []uint32       `protobuf:"varint,20,rep,packed,name=uint32_values,json=uint32Values,proto3" json:"uint32_values,omitempty"`
        Uint64ValueEmpties   []uint64       `protobuf:"varint,22,rep,packed,name=uint64_value_empties,json=uint64ValueEmpties,proto3" json:"uint64_value_empties,omitempty"`
        Uint64ValueNested    []uint64       `protobuf:"varint,23,rep,packed,name=uint64_value_nested,json=uint64ValueNested,proto3" json:"uint64_value_nested,omitempty"`
        Uint64Values         []uint64       `protobuf:"varint,24,rep,packed,name=uint64_values,json=uint64Values,proto3" json:"uint64_values,omitempty"`
        Sint32ValueEmpties   []int32        `protobuf:"zigzag32,26,rep,packed,name=sint32_value_empties,json=sint32ValueEmpties,proto3" json:"sint32_value_empties,omitempty"`
        Sint32ValueNested    []int32        `protobuf:"zigzag32,27,rep,packed,name=sint32_value_nested,json=sint32ValueNested,proto3" json:"sint32_value_nested,omitempty"`
        Sint32Values         []int32        `protobuf:"zigzag32,28,rep,packed,name=sint32_values,json=sint32Values,proto3" json:"sint32_values,omitempty"`
        Sint64ValueEmpties   []int64        `protobuf:"zigzag64,30,rep,packed,name=sint64_value_empties,json=sint64ValueEmpties,proto3" json:"sint64_value_empties,omitempty"`
        Sint64ValueNested    []int64        `protobuf:"zigzag64,31,rep,packed,name=sint64_value_nested,json=sint64ValueNested,proto3" json:"sint64_value_nested,omitempty"`
        Sint64Values         []int64        `protobuf:"zigzag64,32,rep,packed,name=sint64_values,json=sint64Values,proto3" json:"sint64_values,omitempty"`
        Fixed32ValueEmpties  []uint32       `protobuf:"fixed32,34,rep,packed,name=fixed32_value_empties,json=fixed32ValueEmpties,proto3" json:"fixed32_value_empties,omitempty"`
        Fixed32ValueNested   []uint32       `protobuf:"fixed32,35,rep,packed,name=fixed32_value_nested,json=fixed32ValueNested,proto3" json:"fixed32_value_nested,omitempty"`
        Fixed32Values        []uint32       `protobuf:"fixed32,36,rep,packed,name=fixed32_values,json=fixed32Values,proto3" json:"fixed32_values,omitempty"`
        Fixed64ValueEmpties  []uint64       `protobuf:"fixed64,38,rep,packed,name=fixed64_value_empties,json=fixed64ValueEmpties,proto3" json:"fixed64_value_empties,omitempty"`
        Fixed64ValueNested   []uint64       `protobuf:"fixed64,39,rep,packed,name=fixed64_value_nested,json=fixed64ValueNested,proto3" json:"fixed64_value_nested,omitempty"`
        Fixed64Values        []uint64       `protobuf:"fixed64,40,rep,packed,name=fixed64_values,json=fixed64Values,proto3" json:"fixed64_values,omitempty"`
        Sfixed32ValueEmpties []int32        `protobuf:"fixed32,42,rep,packed,name=sfixed32_value_empties,json=sfixed32ValueEmpties,proto3" json:"sfixed32_value_empties,omitempty"`
        Sfixed32ValueNested  []int32        `protobuf:"fixed32,43,rep,packed,name=sfixed32_value_nested,json=sfixed32ValueNested,proto3" json:"sfixed32_value_nested,omitempty"`
        Sfixed32Values       []int32        `protobuf:"fixed32,44,rep,packed,name=sfixed32_values,json=sfixed32Values,proto3" json:"sfixed32_values,omitempty"`
        Sfixed64ValueEmpties []int64        `protobuf:"fixed64,46,rep,packed,name=sfixed64_value_empties,json=sfixed64ValueEmpties,proto3" json:"sfixed64_value_empties,omitempty"`
        Sfixed64ValueNested  []int64        `protobuf:"fixed64,47,rep,packed,name=sfixed64_value_nested,json=sfixed64ValueNested,proto3" json:"sfixed64_value_nested,omitempty"`
        Sfixed64Values       []int64        `protobuf:"fixed64,48,rep,packed,name=sfixed64_values,json=sfixed64Values,proto3" json:"sfixed64_values,omitempty"`
        BoolValueEmpties     []bool         `protobuf:"varint,50,rep,packed,name=bool_value_empties,json=boolValueEmpties,proto3" json:"bool_value_empties,omitempty"`
        BoolValueNested      []bool         `protobuf:"varint,51,rep,packed,name=bool_value_nested,json=boolValueNested,proto3" json:"bool_value_nested,omitempty"`
        BoolValues           []bool         `protobuf:"varint,52,rep,packed,name=bool_values,json=boolValues,proto3" json:"bool_values,omitempty"`
        StringValueEmpties   []string       `protobuf:"bytes,54,rep,name=string_value_empties,json=stringValueEmpties,proto3" json:"string_value_empties,omitempty"`
        StringValueNested    []string       `protobuf:"bytes,55,rep,name=string_value_nested,json=stringValueNested,proto3" json:"string_value_nested,omitempty"`
        StringValues         []string       `protobuf:"bytes,56,rep,name=string_values,json=stringValues,proto3" json:"string_values,omitempty"`
        BytesValueEmpties    [][]byte       `protobuf:"bytes,58,rep,name=bytes_value_empties,json=bytesValueEmpties,proto3" json:"bytes_value_empties,omitempty"`
        BytesValueNested     [][]byte       `protobuf:"bytes,59,rep,name=bytes_value_nested,json=bytesValueNested,proto3" json:"bytes_value_nested,omitempty"`
        BytesValues          [][]byte       `protobuf:"bytes,60,rep,name=bytes_values,json=bytesValues,proto3" json:"bytes_values,omitempty"`
        EnumValueEmpties     []TestEnum     `protobuf:"varint,62,rep,packed,name=enum_value_empties,json=enumValueEmpties,proto3,enum=tests.TestEnum" json:"enum_value_empties,omitempty"`
        EnumValueNested      []TestEnum     `protobuf:"varint,63,rep,packed,name=enum_value_nested,json=enumValueNested,proto3,enum=tests.TestEnum" json:"enum_value_nested,omitempty"`
        EnumValues           []TestEnum     `protobuf:"varint,64,rep,packed,name=enum_values,json=enumValues,proto3,enum=tests.TestEnum" json:"enum_values,omitempty"`
        MessageNils          []*TestMessage `protobuf:"bytes,66,rep,name=message_nils,json=messageNils,proto3" json:"message_nils,omitempty"`
        MessageSkips         []*TestMessage `protobuf:"bytes,67,rep,name=message_skips,json=messageSkips,proto3" json:"message_skips,omitempty"`
        MessageNested        []*TestMessage `protobuf:"bytes,68,rep,name=message_nested,json=messageNested,proto3" json:"message_nested,omitempty"`
        MessageEmpties       []*TestMessage `protobuf:"bytes,69,rep,name=message_empties,json=messageEmpties,proto3" json:"message_empties,omitempty"`
}

func (x *RepeatedM) Reset() <span class="cov0" title="0">{
        *x = RepeatedM{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_examples_tests_message_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RepeatedM) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RepeatedM) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RepeatedM) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_examples_tests_message_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RepeatedM.ProtoReflect.Descriptor instead.
func (*RepeatedM) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_examples_tests_message_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RepeatedM) GetFloatValueEmpties() []float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FloatValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetFloatValueNested() []float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FloatValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetFloatValues() []float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FloatValues
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetDoubleValueEmpties() []float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DoubleValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetDoubleValueNested() []float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DoubleValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetDoubleValues() []float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DoubleValues
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetInt32ValueEmpties() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Int32ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetInt32ValueNested() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Int32ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetInt32Values() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Int32Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetInt64ValueEmpties() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Int64ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetInt64ValueNested() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Int64ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetInt64Values() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Int64Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetUint32ValueEmpties() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uint32ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetUint32ValueNested() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uint32ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetUint32Values() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uint32Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetUint64ValueEmpties() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uint64ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetUint64ValueNested() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uint64ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetUint64Values() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uint64Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSint32ValueEmpties() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sint32ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSint32ValueNested() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sint32ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSint32Values() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sint32Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSint64ValueEmpties() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sint64ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSint64ValueNested() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sint64ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSint64Values() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sint64Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetFixed32ValueEmpties() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fixed32ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetFixed32ValueNested() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fixed32ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetFixed32Values() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fixed32Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetFixed64ValueEmpties() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fixed64ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetFixed64ValueNested() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fixed64ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetFixed64Values() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fixed64Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSfixed32ValueEmpties() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sfixed32ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSfixed32ValueNested() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sfixed32ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSfixed32Values() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sfixed32Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSfixed64ValueEmpties() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sfixed64ValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSfixed64ValueNested() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sfixed64ValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetSfixed64Values() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sfixed64Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetBoolValueEmpties() []bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BoolValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetBoolValueNested() []bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BoolValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetBoolValues() []bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BoolValues
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetStringValueEmpties() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StringValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetStringValueNested() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StringValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetStringValues() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StringValues
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetBytesValueEmpties() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BytesValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetBytesValueNested() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BytesValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetBytesValues() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BytesValues
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetEnumValueEmpties() []TestEnum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EnumValueEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetEnumValueNested() []TestEnum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EnumValueNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetEnumValues() []TestEnum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EnumValues
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetMessageNils() []*TestMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageNils
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetMessageSkips() []*TestMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageSkips
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetMessageNested() []*TestMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageNested
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedM) GetMessageEmpties() []*TestMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageEmpties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_examples_tests_message_proto protoreflect.FileDescriptor

var file_examples_tests_message_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x73,
        0x2f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05,
        0x74, 0x65, 0x73, 0x74, 0x73, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x1a, 0x16, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x2f, 0x76, 0x33, 0x2f, 0x72, 0x65,
        0x64, 0x61, 0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xe6, 0x11, 0x0a, 0x0b, 0x54,
        0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x2a, 0x0a, 0x0b, 0x66, 0x6c,
        0x6f, 0x61, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x42,
        0x09, 0xda, 0xb6, 0x1a, 0x05, 0x15, 0xcd, 0xcc, 0x4c, 0x40, 0x52, 0x0a, 0x66, 0x6c, 0x6f, 0x61,
        0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x30, 0x0a, 0x0c, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65,
        0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x42, 0x0d, 0xda, 0xb6,
        0x1a, 0x09, 0x19, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0x19, 0x40, 0x52, 0x0b, 0x64, 0x6f, 0x75,
        0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x27, 0x0a, 0x0b, 0x69, 0x6e, 0x74, 0x33,
        0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x42, 0x06, 0xda,
        0xb6, 0x1a, 0x02, 0x20, 0x20, 0x52, 0x0a, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75,
        0x65, 0x12, 0x27, 0x0a, 0x0b, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x08, 0x20, 0x01, 0x28, 0x03, 0x42, 0x06, 0xda, 0xb6, 0x1a, 0x02, 0x28, 0x40, 0x52, 0x0a,
        0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x29, 0x0a, 0x0c, 0x75, 0x69,
        0x6e, 0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d,
        0x42, 0x06, 0xda, 0xb6, 0x1a, 0x02, 0x30, 0x20, 0x52, 0x0b, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x29, 0x0a, 0x0c, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x04, 0x42, 0x06, 0xda, 0xb6, 0x1a,
        0x02, 0x38, 0x40, 0x52, 0x0b, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x12, 0x29, 0x0a, 0x0c, 0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x0e, 0x20, 0x01, 0x28, 0x11, 0x42, 0x06, 0xda, 0xb6, 0x1a, 0x02, 0x40, 0x40, 0x52, 0x0b,
        0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x2a, 0x0a, 0x0c, 0x73,
        0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x10, 0x20, 0x01, 0x28,
        0x12, 0x42, 0x07, 0xda, 0xb6, 0x1a, 0x03, 0x48, 0x80, 0x01, 0x52, 0x0b, 0x73, 0x69, 0x6e, 0x74,
        0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x2e, 0x0a, 0x0d, 0x66, 0x69, 0x78, 0x65, 0x64,
        0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x12, 0x20, 0x01, 0x28, 0x07, 0x42, 0x09,
        0xda, 0xb6, 0x1a, 0x05, 0x55, 0x20, 0x00, 0x00, 0x00, 0x52, 0x0c, 0x66, 0x69, 0x78, 0x65, 0x64,
        0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x32, 0x0a, 0x0d, 0x66, 0x69, 0x78, 0x65, 0x64,
        0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x14, 0x20, 0x01, 0x28, 0x06, 0x42, 0x0d,
        0xda, 0xb6, 0x1a, 0x09, 0x59, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x0c, 0x66,
        0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x30, 0x0a, 0x0e, 0x73,
        0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x16, 0x20,
        0x01, 0x28, 0x0f, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0x65, 0x20, 0x00, 0x00, 0x00, 0x52, 0x0d,
        0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x34, 0x0a,
        0x0e, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x18, 0x20, 0x01, 0x28, 0x10, 0x42, 0x0d, 0xda, 0xb6, 0x1a, 0x09, 0x69, 0x40, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x52, 0x0d, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x12, 0x25, 0x0a, 0x0a, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x08, 0x42, 0x06, 0xda, 0xb6, 0x1a, 0x02, 0x70, 0x01, 0x52,
        0x09, 0x62, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x3d, 0x0a, 0x0c, 0x73, 0x74,
        0x72, 0x69, 0x6e, 0x67, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x1c, 0x20, 0x01, 0x28, 0x09,
        0x42, 0x1a, 0xda, 0xb6, 0x1a, 0x16, 0x7a, 0x14, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x65, 0x64,
        0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x0b, 0x73, 0x74,
        0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x3c, 0x0a, 0x0b, 0x62, 0x79, 0x74,
        0x65, 0x73, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x1e, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x1b,
        0xda, 0xb6, 0x1a, 0x17, 0x82, 0x01, 0x14, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x65, 0x64, 0x2d,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x0a, 0x62, 0x79, 0x74,
        0x65, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x37, 0x0a, 0x0a, 0x65, 0x6e, 0x75, 0x6d, 0x5f,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x20, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0f, 0x2e, 0x74, 0x65,
        0x73, 0x74, 0x73, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x45, 0x6e, 0x75, 0x6d, 0x42, 0x07, 0xda, 0xb6,
        0x1a, 0x03, 0x88, 0x01, 0x02, 0x52, 0x09, 0x65, 0x6e, 0x75, 0x6d, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x12, 0x3e, 0x0a, 0x0b, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x6e, 0x69, 0x6c, 0x18,
        0x22, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65,
        0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0x9a,
        0x01, 0x02, 0x18, 0x01, 0x52, 0x0a, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4e, 0x69, 0x6c,
        0x12, 0x40, 0x0a, 0x0c, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x73, 0x6b, 0x69, 0x70,
        0x18, 0x23, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54,
        0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05,
        0x9a, 0x01, 0x02, 0x08, 0x01, 0x52, 0x0b, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x53, 0x6b,
        0x69, 0x70, 0x12, 0x42, 0x0a, 0x0d, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x65, 0x6d,
        0x70, 0x74, 0x79, 0x18, 0x24, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74,
        0x73, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x09, 0xda,
        0xb6, 0x1a, 0x05, 0x9a, 0x01, 0x02, 0x10, 0x01, 0x52, 0x0c, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
        0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x4b, 0x0a, 0x0a, 0x6d, 0x61, 0x70, 0x31, 0x5f, 0x65,
        0x6d, 0x70, 0x74, 0x79, 0x18, 0x27, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x74, 0x65, 0x73,
        0x74, 0x73, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x4d,
        0x61, 0x70, 0x31, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x42, 0x09, 0xda,
        0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x09, 0x6d, 0x61, 0x70, 0x31, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x12, 0x4b, 0x0a, 0x0a, 0x6d, 0x61, 0x70, 0x32, 0x5f, 0x65, 0x6d, 0x70, 0x74,
        0x79, 0x18, 0x28, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e,
        0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x4d, 0x61, 0x70, 0x32,
        0x45, 0x6d, 0x70, 0x74, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05,
        0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x09, 0x6d, 0x61, 0x70, 0x32, 0x45, 0x6d, 0x70, 0x74, 0x79,
        0x12, 0x4e, 0x0a, 0x0b, 0x6d, 0x61, 0x70, 0x31, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18,
        0x29, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65,
        0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x4d, 0x61, 0x70, 0x31, 0x4e, 0x65,
        0x73, 0x74, 0x65, 0x64, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2,
        0x01, 0x02, 0x10, 0x01, 0x52, 0x0a, 0x6d, 0x61, 0x70, 0x31, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64,
        0x12, 0x4e, 0x0a, 0x0b, 0x6d, 0x61, 0x70, 0x32, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18,
        0x2a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65,
        0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x4d, 0x61, 0x70, 0x32, 0x4e, 0x65,
        0x73, 0x74, 0x65, 0x64, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2,
        0x01, 0x02, 0x10, 0x01, 0x52, 0x0a, 0x6d, 0x61, 0x70, 0x32, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64,
        0x12, 0x4b, 0x0a, 0x09, 0x6d, 0x61, 0x70, 0x31, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x18, 0x2b, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65, 0x73, 0x74,
        0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x4d, 0x61, 0x70, 0x31, 0x49, 0x74, 0x65, 0x6d,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x42, 0x0c, 0xda, 0xb6, 0x1a, 0x08, 0xa2, 0x01, 0x05, 0x1a, 0x03,
        0x7a, 0x01, 0x33, 0x52, 0x08, 0x6d, 0x61, 0x70, 0x31, 0x49, 0x74, 0x65, 0x6d, 0x12, 0x57, 0x0a,
        0x0d, 0x6d, 0x61, 0x70, 0x32, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x6e, 0x69, 0x6c, 0x18, 0x2c,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65, 0x73,
        0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x4d, 0x61, 0x70, 0x32, 0x49, 0x74, 0x65,
        0x6d, 0x4e, 0x69, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x42, 0x0e, 0xda, 0xb6, 0x1a, 0x0a, 0xa2,
        0x01, 0x07, 0x1a, 0x05, 0x9a, 0x01, 0x02, 0x18, 0x01, 0x52, 0x0b, 0x6d, 0x61, 0x70, 0x32, 0x49,
        0x74, 0x65, 0x6d, 0x4e, 0x69, 0x6c, 0x12, 0x5a, 0x0a, 0x0e, 0x6d, 0x61, 0x70, 0x32, 0x5f, 0x69,
        0x74, 0x65, 0x6d, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x18, 0x2d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24,
        0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61,
        0x67, 0x65, 0x2e, 0x4d, 0x61, 0x70, 0x32, 0x49, 0x74, 0x65, 0x6d, 0x53, 0x6b, 0x69, 0x70, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x42, 0x0e, 0xda, 0xb6, 0x1a, 0x0a, 0xa2, 0x01, 0x07, 0x1a, 0x05, 0x9a,
        0x01, 0x02, 0x08, 0x01, 0x52, 0x0c, 0x6d, 0x61, 0x70, 0x32, 0x49, 0x74, 0x65, 0x6d, 0x53, 0x6b,
        0x69, 0x70, 0x12, 0x5d, 0x0a, 0x0f, 0x6d, 0x61, 0x70, 0x32, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x5f,
        0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x2e, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x74, 0x65,
        0x73, 0x74, 0x73, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e,
        0x4d, 0x61, 0x70, 0x32, 0x49, 0x74, 0x65, 0x6d, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x45, 0x6e, 0x74,
        0x72, 0x79, 0x42, 0x0e, 0xda, 0xb6, 0x1a, 0x0a, 0xa2, 0x01, 0x07, 0x1a, 0x05, 0x9a, 0x01, 0x02,
        0x10, 0x01, 0x52, 0x0d, 0x6d, 0x61, 0x70, 0x32, 0x49, 0x74, 0x65, 0x6d, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x1a, 0x3c, 0x0a, 0x0e, 0x4d, 0x61, 0x70, 0x31, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
        0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a,
        0x54, 0x0a, 0x0e, 0x4d, 0x61, 0x70, 0x32, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
        0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3d, 0x0a, 0x0f, 0x4d, 0x61, 0x70, 0x31, 0x4e, 0x65, 0x73,
        0x74, 0x65, 0x64, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x4d, 0x61, 0x70, 0x32, 0x4e, 0x65, 0x73, 0x74,
        0x65, 0x64, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,
        0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3b, 0x0a, 0x0d, 0x4d,
        0x61, 0x70, 0x31, 0x49, 0x74, 0x65, 0x6d, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x56, 0x0a, 0x10, 0x4d, 0x61, 0x70, 0x32,
        0x49, 0x74, 0x65, 0x6d, 0x4e, 0x69, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
        0x1a, 0x57, 0x0a, 0x11, 0x4d, 0x61, 0x70, 0x32, 0x49, 0x74, 0x65, 0x6d, 0x53, 0x6b, 0x69, 0x70,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x58, 0x0a, 0x12, 0x4d, 0x61, 0x70,
        0x32, 0x49, 0x74, 0x65, 0x6d, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
        0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65,
        0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
        0x02, 0x38, 0x01, 0x22, 0xc3, 0x18, 0x0a, 0x09, 0x52, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64,
        0x4d, 0x12, 0x39, 0x0a, 0x13, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x02, 0x42, 0x09,
        0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x11, 0x66, 0x6c, 0x6f, 0x61, 0x74,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x37, 0x0a, 0x12,
        0x66, 0x6c, 0x6f, 0x61, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74,
        0x65, 0x64, 0x18, 0x03, 0x20, 0x03, 0x28, 0x02, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01,
        0x02, 0x10, 0x01, 0x52, 0x10, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e,
        0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x31, 0x0a, 0x0c, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x5f, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x02, 0x42, 0x0e, 0xda, 0xb6, 0x1a,
        0x0a, 0xa2, 0x01, 0x07, 0x1a, 0x05, 0x15, 0xcd, 0xcc, 0x4c, 0x40, 0x52, 0x0b, 0x66, 0x6c, 0x6f,
        0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x3b, 0x0a, 0x14, 0x64, 0x6f, 0x75, 0x62,
        0x6c, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73,
        0x18, 0x06, 0x20, 0x03, 0x28, 0x01, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08,
        0x01, 0x52, 0x12, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d,
        0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x39, 0x0a, 0x13, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x5f,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x07, 0x20, 0x03,
        0x28, 0x01, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x11, 0x64,
        0x6f, 0x75, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64,
        0x12, 0x37, 0x0a, 0x0d, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x01, 0x42, 0x12, 0xda, 0xb6, 0x1a, 0x0e, 0xa2, 0x01, 0x0b,
        0x1a, 0x09, 0x19, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0x19, 0x40, 0x52, 0x0c, 0x64, 0x6f, 0x75,
        0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x39, 0x0a, 0x13, 0x69, 0x6e, 0x74,
        0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73,
        0x18, 0x0a, 0x20, 0x03, 0x28, 0x05, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08,
        0x01, 0x52, 0x11, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70,
        0x74, 0x69, 0x65, 0x73, 0x12, 0x37, 0x0a, 0x12, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x5f, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x05,
        0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x10, 0x69, 0x6e, 0x74,
        0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x2e, 0x0a,
        0x0c, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x0c, 0x20,
        0x03, 0x28, 0x05, 0x42, 0x0b, 0xda, 0xb6, 0x1a, 0x07, 0xa2, 0x01, 0x04, 0x1a, 0x02, 0x20, 0x20,
        0x52, 0x0b, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x39, 0x0a,
        0x13, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70,
        0x74, 0x69, 0x65, 0x73, 0x18, 0x0e, 0x20, 0x03, 0x28, 0x03, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05,
        0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x11, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75,
        0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x37, 0x0a, 0x12, 0x69, 0x6e, 0x74, 0x36,
        0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x0f,
        0x20, 0x03, 0x28, 0x03, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52,
        0x10, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65,
        0x64, 0x12, 0x2e, 0x0a, 0x0c, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x73, 0x18, 0x10, 0x20, 0x03, 0x28, 0x03, 0x42, 0x0b, 0xda, 0xb6, 0x1a, 0x07, 0xa2, 0x01, 0x04,
        0x1a, 0x02, 0x28, 0x40, 0x52, 0x0b, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x73, 0x12, 0x3b, 0x0a, 0x14, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x12, 0x20, 0x03, 0x28, 0x0d, 0x42,
        0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x12, 0x75, 0x69, 0x6e, 0x74,
        0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x39,
        0x0a, 0x13, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e,
        0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x13, 0x20, 0x03, 0x28, 0x0d, 0x42, 0x09, 0xda, 0xb6, 0x1a,
        0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x11, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x30, 0x0a, 0x0d, 0x75, 0x69, 0x6e,
        0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x14, 0x20, 0x03, 0x28, 0x0d,
        0x42, 0x0b, 0xda, 0xb6, 0x1a, 0x07, 0xa2, 0x01, 0x04, 0x1a, 0x02, 0x30, 0x20, 0x52, 0x0c, 0x75,
        0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x3b, 0x0a, 0x14, 0x75,
        0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74,
        0x69, 0x65, 0x73, 0x18, 0x16, 0x20, 0x03, 0x28, 0x04, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2,
        0x01, 0x02, 0x08, 0x01, 0x52, 0x12, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75,
        0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x39, 0x0a, 0x13, 0x75, 0x69, 0x6e, 0x74,
        0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18,
        0x17, 0x20, 0x03, 0x28, 0x04, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01,
        0x52, 0x11, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73,
        0x74, 0x65, 0x64, 0x12, 0x30, 0x0a, 0x0d, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x73, 0x18, 0x18, 0x20, 0x03, 0x28, 0x04, 0x42, 0x0b, 0xda, 0xb6, 0x1a, 0x07,
        0xa2, 0x01, 0x04, 0x1a, 0x02, 0x38, 0x40, 0x52, 0x0c, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56,
        0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x3b, 0x0a, 0x14, 0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x5f,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x1a, 0x20,
        0x03, 0x28, 0x11, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x12,
        0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69,
        0x65, 0x73, 0x12, 0x39, 0x0a, 0x13, 0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x1b, 0x20, 0x03, 0x28, 0x11, 0x42,
        0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x11, 0x73, 0x69, 0x6e, 0x74,
        0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x30, 0x0a,
        0x0d, 0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x1c,
        0x20, 0x03, 0x28, 0x11, 0x42, 0x0b, 0xda, 0xb6, 0x1a, 0x07, 0xa2, 0x01, 0x04, 0x1a, 0x02, 0x40,
        0x40, 0x52, 0x0c, 0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12,
        0x3b, 0x0a, 0x14, 0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f,
        0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x1e, 0x20, 0x03, 0x28, 0x12, 0x42, 0x09, 0xda,
        0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x12, 0x73, 0x69, 0x6e, 0x74, 0x36, 0x34,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x39, 0x0a, 0x13,
        0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73,
        0x74, 0x65, 0x64, 0x18, 0x1f, 0x20, 0x03, 0x28, 0x12, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2,
        0x01, 0x02, 0x10, 0x01, 0x52, 0x11, 0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75,
        0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x31, 0x0a, 0x0d, 0x73, 0x69, 0x6e, 0x74, 0x36,
        0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x20, 0x20, 0x03, 0x28, 0x12, 0x42, 0x0c,
        0xda, 0xb6, 0x1a, 0x08, 0xa2, 0x01, 0x05, 0x1a, 0x03, 0x48, 0x80, 0x01, 0x52, 0x0c, 0x73, 0x69,
        0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x3d, 0x0a, 0x15, 0x66, 0x69,
        0x78, 0x65, 0x64, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74,
        0x69, 0x65, 0x73, 0x18, 0x22, 0x20, 0x03, 0x28, 0x07, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2,
        0x01, 0x02, 0x08, 0x01, 0x52, 0x13, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x56, 0x61, 0x6c,
        0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x3b, 0x0a, 0x14, 0x66, 0x69, 0x78,
        0x65, 0x64, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65,
        0x64, 0x18, 0x23, 0x20, 0x03, 0x28, 0x07, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02,
        0x10, 0x01, 0x52, 0x12, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x35, 0x0a, 0x0e, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33,
        0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x24, 0x20, 0x03, 0x28, 0x07, 0x42, 0x0e,
        0xda, 0xb6, 0x1a, 0x0a, 0xa2, 0x01, 0x07, 0x1a, 0x05, 0x55, 0x20, 0x00, 0x00, 0x00, 0x52, 0x0d,
        0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x3d, 0x0a,
        0x15, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65,
        0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x26, 0x20, 0x03, 0x28, 0x06, 0x42, 0x09, 0xda, 0xb6,
        0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x13, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x3b, 0x0a, 0x14,
        0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65,
        0x73, 0x74, 0x65, 0x64, 0x18, 0x27, 0x20, 0x03, 0x28, 0x06, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05,
        0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x12, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x39, 0x0a, 0x0e, 0x66, 0x69, 0x78,
        0x65, 0x64, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x28, 0x20, 0x03, 0x28,
        0x06, 0x42, 0x12, 0xda, 0xb6, 0x1a, 0x0e, 0xa2, 0x01, 0x0b, 0x1a, 0x09, 0x59, 0x40, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x0d, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x73, 0x12, 0x3f, 0x0a, 0x16, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32,
        0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x2a,
        0x20, 0x03, 0x28, 0x0f, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52,
        0x14, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d,
        0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x3d, 0x0a, 0x15, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33,
        0x32, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x2b,
        0x20, 0x03, 0x28, 0x0f, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52,
        0x13, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65,
        0x73, 0x74, 0x65, 0x64, 0x12, 0x37, 0x0a, 0x0f, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32,
        0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x2c, 0x20, 0x03, 0x28, 0x0f, 0x42, 0x0e, 0xda,
        0xb6, 0x1a, 0x0a, 0xa2, 0x01, 0x07, 0x1a, 0x05, 0x65, 0x20, 0x00, 0x00, 0x00, 0x52, 0x0e, 0x73,
        0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x3f, 0x0a,
        0x16, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f,
        0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x2e, 0x20, 0x03, 0x28, 0x10, 0x42, 0x09, 0xda,
        0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x14, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64,
        0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x3d,
        0x0a, 0x15, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x2f, 0x20, 0x03, 0x28, 0x10, 0x42, 0x09, 0xda,
        0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x13, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64,
        0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x3b, 0x0a,
        0x0f, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73,
        0x18, 0x30, 0x20, 0x03, 0x28, 0x10, 0x42, 0x12, 0xda, 0xb6, 0x1a, 0x0e, 0xa2, 0x01, 0x0b, 0x1a,
        0x09, 0x69, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x0e, 0x73, 0x66, 0x69, 0x78,
        0x65, 0x64, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x37, 0x0a, 0x12, 0x62, 0x6f,
        0x6f, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73,
        0x18, 0x32, 0x20, 0x03, 0x28, 0x08, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08,
        0x01, 0x52, 0x10, 0x62, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70, 0x74,
        0x69, 0x65, 0x73, 0x12, 0x35, 0x0a, 0x11, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x33, 0x20, 0x03, 0x28, 0x08, 0x42, 0x09,
        0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x0f, 0x62, 0x6f, 0x6f, 0x6c, 0x56,
        0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x2c, 0x0a, 0x0b, 0x62, 0x6f,
        0x6f, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x34, 0x20, 0x03, 0x28, 0x08, 0x42,
        0x0b, 0xda, 0xb6, 0x1a, 0x07, 0xa2, 0x01, 0x04, 0x1a, 0x02, 0x70, 0x01, 0x52, 0x0a, 0x62, 0x6f,
        0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x3b, 0x0a, 0x14, 0x73, 0x74, 0x72, 0x69,
        0x6e, 0x67, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73,
        0x18, 0x36, 0x20, 0x03, 0x28, 0x09, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08,
        0x01, 0x52, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d,
        0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x39, 0x0a, 0x13, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x5f,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x37, 0x20, 0x03,
        0x28, 0x09, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x11, 0x73,
        0x74, 0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64,
        0x12, 0x44, 0x0a, 0x0d, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x73, 0x18, 0x38, 0x20, 0x03, 0x28, 0x09, 0x42, 0x1f, 0xda, 0xb6, 0x1a, 0x1b, 0xa2, 0x01, 0x18,
        0x1a, 0x16, 0x7a, 0x14, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x65, 0x64, 0x2d, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x0c, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x39, 0x0a, 0x13, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x3a, 0x20,
        0x03, 0x28, 0x0c, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x11,
        0x62, 0x79, 0x74, 0x65, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65,
        0x73, 0x12, 0x37, 0x0a, 0x12, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x3b, 0x20, 0x03, 0x28, 0x0c, 0x42, 0x09, 0xda,
        0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01, 0x52, 0x10, 0x62, 0x79, 0x74, 0x65, 0x73, 0x56,
        0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x43, 0x0a, 0x0c, 0x62, 0x79,
        0x74, 0x65, 0x73, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x3c, 0x20, 0x03, 0x28, 0x0c,
        0x42, 0x20, 0xda, 0xb6, 0x1a, 0x1c, 0xa2, 0x01, 0x19, 0x1a, 0x17, 0x82, 0x01, 0x14, 0x72, 0x65,
        0x64, 0x61, 0x63, 0x74, 0x65, 0x64, 0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2d, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x52, 0x0b, 0x62, 0x79, 0x74, 0x65, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12,
        0x48, 0x0a, 0x12, 0x65, 0x6e, 0x75, 0x6d, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x65, 0x6d,
        0x70, 0x74, 0x69, 0x65, 0x73, 0x18, 0x3e, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x0f, 0x2e, 0x74, 0x65,
        0x73, 0x74, 0x73, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x45, 0x6e, 0x75, 0x6d, 0x42, 0x09, 0xda, 0xb6,
        0x1a, 0x05, 0xa2, 0x01, 0x02, 0x08, 0x01, 0x52, 0x10, 0x65, 0x6e, 0x75, 0x6d, 0x56, 0x61, 0x6c,
        0x75, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x12, 0x46, 0x0a, 0x11, 0x65, 0x6e, 0x75,
        0x6d, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x3f,
        0x20, 0x03, 0x28, 0x0e, 0x32, 0x0f, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65, 0x73,
        0x74, 0x45, 0x6e, 0x75, 0x6d, 0x42, 0x09, 0xda, 0xb6, 0x1a, 0x05, 0xa2, 0x01, 0x02, 0x10, 0x01,
        0x52, 0x0f, 0x65, 0x6e, 0x75, 0x6d, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65,
        0x64, 0x12, 0x3e, 0x0a, 0x0b, 0x65, 0x6e, 0x75, 0x6d, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73,
        0x18, 0x40, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x0f, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54,
        0x65, 0x73, 0x74, 0x45, 0x6e, 0x75, 0x6d, 0x42, 0x0c, 0xda, 0xb6, 0x1a, 0x08, 0xa2, 0x01, 0x05,
        0x1a, 0x03, 0x88, 0x01, 0x02, 0x52, 0x0a, 0x65, 0x6e, 0x75, 0x6d, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x73, 0x12, 0x45, 0x0a, 0x0c, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x6e, 0x69, 0x6c,
        0x73, 0x18, 0x42, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e,
        0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x0e, 0xda, 0xb6, 0x1a,
        0x0a, 0xa2, 0x01, 0x07, 0x1a, 0x05, 0x9a, 0x01, 0x02, 0x18, 0x01, 0x52, 0x0b, 0x6d, 0x65, 0x73,
        0x73, 0x61, 0x67, 0x65, 0x4e, 0x69, 0x6c, 0x73, 0x12, 0x47, 0x0a, 0x0d, 0x6d, 0x65, 0x73, 0x73,
        0x61, 0x67, 0x65, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x73, 0x18, 0x43, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73,
        0x61, 0x67, 0x65, 0x42, 0x0e, 0xda, 0xb6, 0x1a, 0x0a, 0xa2, 0x01, 0x07, 0x1a, 0x05, 0x9a, 0x01,
        0x02, 0x08, 0x01, 0x52, 0x0c, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x53, 0x6b, 0x69, 0x70,
        0x73, 0x12, 0x49, 0x0a, 0x0e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x6e, 0x65, 0x73,
        0x74, 0x65, 0x64, 0x18, 0x44, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74,
        0x73, 0x2e, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x0e, 0xda,
        0xb6, 0x1a, 0x0a, 0xa2, 0x01, 0x07, 0x1a, 0x05, 0x9a, 0x01, 0x02, 0x20, 0x01, 0x52, 0x0d, 0x6d,
        0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x12, 0x4b, 0x0a, 0x0f,
        0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x18,
        0x45, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x54, 0x65,
        0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x0e, 0xda, 0xb6, 0x1a, 0x0a, 0xa2,
        0x01, 0x07, 0x1a, 0x05, 0x9a, 0x01, 0x02, 0x10, 0x01, 0x52, 0x0e, 0x6d, 0x65, 0x73, 0x73, 0x61,
        0x67, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x69, 0x65, 0x73, 0x2a, 0x35, 0x0a, 0x08, 0x54, 0x65, 0x73,
        0x74, 0x45, 0x6e, 0x75, 0x6d, 0x12, 0x0d, 0x0a, 0x09, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x5a, 0x65,
        0x72, 0x6f, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4f, 0x6e, 0x65,
        0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x77, 0x6f, 0x10, 0x02,
        0x42, 0x46, 0x5a, 0x44, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61,
        0x72, 0x72, 0x61, 0x6b, 0x69, 0x73, 0x2d, 0x64, 0x69, 0x67, 0x69, 0x74, 0x61, 0x6c, 0x2f, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74,
        0x2f, 0x76, 0x33, 0x2f, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x2f, 0x74, 0x65, 0x73,
        0x74, 0x73, 0x3b, 0x74, 0x65, 0x73, 0x74, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_examples_tests_message_proto_rawDescOnce sync.Once
        file_examples_tests_message_proto_rawDescData = file_examples_tests_message_proto_rawDesc
)

func file_examples_tests_message_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_examples_tests_message_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_examples_tests_message_proto_rawDescData = protoimpl.X.CompressGZIP(file_examples_tests_message_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_examples_tests_message_proto_rawDescData</span>
}

var file_examples_tests_message_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_examples_tests_message_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_examples_tests_message_proto_goTypes = []interface{}{
        (TestEnum)(0),         // 0: tests.TestEnum
        (*TestMessage)(nil),   // 1: tests.TestMessage
        (*RepeatedM)(nil),     // 2: tests.RepeatedM
        nil,                   // 3: tests.TestMessage.Map1EmptyEntry
        nil,                   // 4: tests.TestMessage.Map2EmptyEntry
        nil,                   // 5: tests.TestMessage.Map1NestedEntry
        nil,                   // 6: tests.TestMessage.Map2NestedEntry
        nil,                   // 7: tests.TestMessage.Map1ItemEntry
        nil,                   // 8: tests.TestMessage.Map2ItemNilEntry
        nil,                   // 9: tests.TestMessage.Map2ItemSkipEntry
        nil,                   // 10: tests.TestMessage.Map2ItemEmptyEntry
        (*emptypb.Empty)(nil), // 11: google.protobuf.Empty
}
var file_examples_tests_message_proto_depIdxs = []int32{
        0,  // 0: tests.TestMessage.enum_value:type_name -&gt; tests.TestEnum
        1,  // 1: tests.TestMessage.message_nil:type_name -&gt; tests.TestMessage
        1,  // 2: tests.TestMessage.message_skip:type_name -&gt; tests.TestMessage
        1,  // 3: tests.TestMessage.message_empty:type_name -&gt; tests.TestMessage
        3,  // 4: tests.TestMessage.map1_empty:type_name -&gt; tests.TestMessage.Map1EmptyEntry
        4,  // 5: tests.TestMessage.map2_empty:type_name -&gt; tests.TestMessage.Map2EmptyEntry
        5,  // 6: tests.TestMessage.map1_nested:type_name -&gt; tests.TestMessage.Map1NestedEntry
        6,  // 7: tests.TestMessage.map2_nested:type_name -&gt; tests.TestMessage.Map2NestedEntry
        7,  // 8: tests.TestMessage.map1_item:type_name -&gt; tests.TestMessage.Map1ItemEntry
        8,  // 9: tests.TestMessage.map2_item_nil:type_name -&gt; tests.TestMessage.Map2ItemNilEntry
        9,  // 10: tests.TestMessage.map2_item_skip:type_name -&gt; tests.TestMessage.Map2ItemSkipEntry
        10, // 11: tests.TestMessage.map2_item_empty:type_name -&gt; tests.TestMessage.Map2ItemEmptyEntry
        0,  // 12: tests.RepeatedM.enum_value_empties:type_name -&gt; tests.TestEnum
        0,  // 13: tests.RepeatedM.enum_value_nested:type_name -&gt; tests.TestEnum
        0,  // 14: tests.RepeatedM.enum_values:type_name -&gt; tests.TestEnum
        1,  // 15: tests.RepeatedM.message_nils:type_name -&gt; tests.TestMessage
        1,  // 16: tests.RepeatedM.message_skips:type_name -&gt; tests.TestMessage
        1,  // 17: tests.RepeatedM.message_nested:type_name -&gt; tests.TestMessage
        1,  // 18: tests.RepeatedM.message_empties:type_name -&gt; tests.TestMessage
        11, // 19: tests.TestMessage.Map2EmptyEntry.value:type_name -&gt; google.protobuf.Empty
        11, // 20: tests.TestMessage.Map2NestedEntry.value:type_name -&gt; google.protobuf.Empty
        11, // 21: tests.TestMessage.Map2ItemNilEntry.value:type_name -&gt; google.protobuf.Empty
        11, // 22: tests.TestMessage.Map2ItemSkipEntry.value:type_name -&gt; google.protobuf.Empty
        11, // 23: tests.TestMessage.Map2ItemEmptyEntry.value:type_name -&gt; google.protobuf.Empty
        24, // [24:24] is the sub-list for method output_type
        24, // [24:24] is the sub-list for method input_type
        24, // [24:24] is the sub-list for extension type_name
        24, // [24:24] is the sub-list for extension extendee
        0,  // [0:24] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_examples_tests_message_proto_init() }</span>
func file_examples_tests_message_proto_init() <span class="cov0" title="0">{
        if File_examples_tests_message_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_examples_tests_message_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TestMessage); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_examples_tests_message_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RepeatedM); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_examples_tests_message_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   10,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_examples_tests_message_proto_goTypes,
                DependencyIndexes: file_examples_tests_message_proto_depIdxs,
                EnumInfos:         file_examples_tests_message_proto_enumTypes,
                MessageInfos:      file_examples_tests_message_proto_msgTypes,
        }.Build()
        File_examples_tests_message_proto = out.File
        file_examples_tests_message_proto_rawDesc = nil
        file_examples_tests_message_proto_goTypes = nil
        file_examples_tests_message_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-redact. DO NOT EDIT.
// source: examples/tests/message.proto

package tests

import (
        context "context"

        redact "github.com/menta2k/protoc-gen-redact/v3/redact/v3"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
        _ grpc.Server
        _ context.Context
        _ redact.Redactor
        _ codes.Code
        _ status.Status
        _ emptypb.Empty
        _ redact.FieldRules
)

// Redact method implementation for TestMessage
func (x *TestMessage) Redact() string <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Redacting field: FloatValue
        <span class="cov0" title="0">x.FloatValue = 3.2

        // Redacting field: DoubleValue
        x.DoubleValue = 6.4

        // Redacting field: Int32Value
        x.Int32Value = 32

        // Redacting field: Int64Value
        x.Int64Value = 64

        // Redacting field: Uint32Value
        x.Uint32Value = 32

        // Redacting field: Uint64Value
        x.Uint64Value = 64

        // Redacting field: Sint32Value
        x.Sint32Value = 32

        // Redacting field: Sint64Value
        x.Sint64Value = 64

        // Redacting field: Fixed32Value
        x.Fixed32Value = 32

        // Redacting field: Fixed64Value
        x.Fixed64Value = 64

        // Redacting field: Sfixed32Value
        x.Sfixed32Value = 32

        // Redacting field: Sfixed64Value
        x.Sfixed64Value = 64

        // Redacting field: BoolValue
        x.BoolValue = true

        // Redacting field: StringValue
        x.StringValue = `redacted-value-value`

        // Redacting field: BytesValue
        x.BytesValue = []byte(`redacted-value-value`)

        // Redacting field: EnumValue
        x.EnumValue = 2

        // Redacting field: MessageNil
        x.MessageNil = nil

        // Redacting field: MessageSkip
        // MessageSkip redaction is skipped

        // Redacting field: MessageEmpty
        x.MessageEmpty = &amp;TestMessage{}

        // Redacting field: Map1Empty
        x.Map1Empty = map[int64]string{}

        // Redacting field: Map2Empty
        x.Map2Empty = map[string]*emptypb.Empty{}

        // Redacting field: Map1Nested
        for k := range x.Map1Nested </span><span class="cov0" title="0">{
                x.Map1Nested[k] = "REDACTED"
        }</span>

        // Redacting field: Map2Nested
        <span class="cov0" title="0">for k := range x.Map2Nested </span><span class="cov0" title="0">{
                redact.Apply(x.Map2Nested[k])
        }</span>

        // Redacting field: Map1Item
        <span class="cov0" title="0">for k := range x.Map1Item </span><span class="cov0" title="0">{
                x.Map1Item[k] = `3`
        }</span>

        // Redacting field: Map2ItemNil
        <span class="cov0" title="0">for k := range x.Map2ItemNil </span><span class="cov0" title="0">{
                x.Map2ItemNil[k] = nil
        }</span>

        // Redacting field: Map2ItemSkip
        // Map2ItemSkip redaction is skipped

        // Redacting field: Map2ItemEmpty
        <span class="cov0" title="0">for k := range x.Map2ItemEmpty </span><span class="cov0" title="0">{
                x.Map2ItemEmpty[k] = &amp;emptypb.Empty{}
        }</span>
        <span class="cov0" title="0">return x.String()</span>
}

// Redact method implementation for RepeatedM
func (x *RepeatedM) Redact() string <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Redacting field: FloatValueEmpties
        <span class="cov0" title="0">x.FloatValueEmpties = []float32{}

        // Redacting field: FloatValueNested
        for k := range x.FloatValueNested </span><span class="cov0" title="0">{
                x.FloatValueNested[k] = 0
        }</span>

        // Redacting field: FloatValues
        <span class="cov0" title="0">for k := range x.FloatValues </span><span class="cov0" title="0">{
                x.FloatValues[k] = 3.2
        }</span>

        // Redacting field: DoubleValueEmpties
        <span class="cov0" title="0">x.DoubleValueEmpties = []float64{}

        // Redacting field: DoubleValueNested
        for k := range x.DoubleValueNested </span><span class="cov0" title="0">{
                x.DoubleValueNested[k] = 0
        }</span>

        // Redacting field: DoubleValues
        <span class="cov0" title="0">for k := range x.DoubleValues </span><span class="cov0" title="0">{
                x.DoubleValues[k] = 6.4
        }</span>

        // Redacting field: Int32ValueEmpties
        <span class="cov0" title="0">x.Int32ValueEmpties = []int32{}

        // Redacting field: Int32ValueNested
        for k := range x.Int32ValueNested </span><span class="cov0" title="0">{
                x.Int32ValueNested[k] = 0
        }</span>

        // Redacting field: Int32Values
        <span class="cov0" title="0">for k := range x.Int32Values </span><span class="cov0" title="0">{
                x.Int32Values[k] = 32
        }</span>

        // Redacting field: Int64ValueEmpties
        <span class="cov0" title="0">x.Int64ValueEmpties = []int64{}

        // Redacting field: Int64ValueNested
        for k := range x.Int64ValueNested </span><span class="cov0" title="0">{
                x.Int64ValueNested[k] = 0
        }</span>

        // Redacting field: Int64Values
        <span class="cov0" title="0">for k := range x.Int64Values </span><span class="cov0" title="0">{
                x.Int64Values[k] = 64
        }</span>

        // Redacting field: Uint32ValueEmpties
        <span class="cov0" title="0">x.Uint32ValueEmpties = []uint32{}

        // Redacting field: Uint32ValueNested
        for k := range x.Uint32ValueNested </span><span class="cov0" title="0">{
                x.Uint32ValueNested[k] = 0
        }</span>

        // Redacting field: Uint32Values
        <span class="cov0" title="0">for k := range x.Uint32Values </span><span class="cov0" title="0">{
                x.Uint32Values[k] = 32
        }</span>

        // Redacting field: Uint64ValueEmpties
        <span class="cov0" title="0">x.Uint64ValueEmpties = []uint64{}

        // Redacting field: Uint64ValueNested
        for k := range x.Uint64ValueNested </span><span class="cov0" title="0">{
                x.Uint64ValueNested[k] = 0
        }</span>

        // Redacting field: Uint64Values
        <span class="cov0" title="0">for k := range x.Uint64Values </span><span class="cov0" title="0">{
                x.Uint64Values[k] = 64
        }</span>

        // Redacting field: Sint32ValueEmpties
        <span class="cov0" title="0">x.Sint32ValueEmpties = []int32{}

        // Redacting field: Sint32ValueNested
        for k := range x.Sint32ValueNested </span><span class="cov0" title="0">{
                x.Sint32ValueNested[k] = 0
        }</span>

        // Redacting field: Sint32Values
        <span class="cov0" title="0">for k := range x.Sint32Values </span><span class="cov0" title="0">{
                x.Sint32Values[k] = 32
        }</span>

        // Redacting field: Sint64ValueEmpties
        <span class="cov0" title="0">x.Sint64ValueEmpties = []int64{}

        // Redacting field: Sint64ValueNested
        for k := range x.Sint64ValueNested </span><span class="cov0" title="0">{
                x.Sint64ValueNested[k] = 0
        }</span>

        // Redacting field: Sint64Values
        <span class="cov0" title="0">for k := range x.Sint64Values </span><span class="cov0" title="0">{
                x.Sint64Values[k] = 64
        }</span>

        // Redacting field: Fixed32ValueEmpties
        <span class="cov0" title="0">x.Fixed32ValueEmpties = []uint32{}

        // Redacting field: Fixed32ValueNested
        for k := range x.Fixed32ValueNested </span><span class="cov0" title="0">{
                x.Fixed32ValueNested[k] = 0
        }</span>

        // Redacting field: Fixed32Values
        <span class="cov0" title="0">for k := range x.Fixed32Values </span><span class="cov0" title="0">{
                x.Fixed32Values[k] = 32
        }</span>

        // Redacting field: Fixed64ValueEmpties
        <span class="cov0" title="0">x.Fixed64ValueEmpties = []uint64{}

        // Redacting field: Fixed64ValueNested
        for k := range x.Fixed64ValueNested </span><span class="cov0" title="0">{
                x.Fixed64ValueNested[k] = 0
        }</span>

        // Redacting field: Fixed64Values
        <span class="cov0" title="0">for k := range x.Fixed64Values </span><span class="cov0" title="0">{
                x.Fixed64Values[k] = 64
        }</span>

        // Redacting field: Sfixed32ValueEmpties
        <span class="cov0" title="0">x.Sfixed32ValueEmpties = []int32{}

        // Redacting field: Sfixed32ValueNested
        for k := range x.Sfixed32ValueNested </span><span class="cov0" title="0">{
                x.Sfixed32ValueNested[k] = 0
        }</span>

        // Redacting field: Sfixed32Values
        <span class="cov0" title="0">for k := range x.Sfixed32Values </span><span class="cov0" title="0">{
                x.Sfixed32Values[k] = 32
        }</span>

        // Redacting field: Sfixed64ValueEmpties
        <span class="cov0" title="0">x.Sfixed64ValueEmpties = []int64{}

        // Redacting field: Sfixed64ValueNested
        for k := range x.Sfixed64ValueNested </span><span class="cov0" title="0">{
                x.Sfixed64ValueNested[k] = 0
        }</span>

        // Redacting field: Sfixed64Values
        <span class="cov0" title="0">for k := range x.Sfixed64Values </span><span class="cov0" title="0">{
                x.Sfixed64Values[k] = 64
        }</span>

        // Redacting field: BoolValueEmpties
        <span class="cov0" title="0">x.BoolValueEmpties = []bool{}

        // Redacting field: BoolValueNested
        for k := range x.BoolValueNested </span><span class="cov0" title="0">{
                x.BoolValueNested[k] = false
        }</span>

        // Redacting field: BoolValues
        <span class="cov0" title="0">for k := range x.BoolValues </span><span class="cov0" title="0">{
                x.BoolValues[k] = true
        }</span>

        // Redacting field: StringValueEmpties
        <span class="cov0" title="0">x.StringValueEmpties = []string{}

        // Redacting field: StringValueNested
        for k := range x.StringValueNested </span><span class="cov0" title="0">{
                x.StringValueNested[k] = "REDACTED"
        }</span>

        // Redacting field: StringValues
        <span class="cov0" title="0">for k := range x.StringValues </span><span class="cov0" title="0">{
                x.StringValues[k] = `redacted-value-value`
        }</span>

        // Redacting field: BytesValueEmpties
        <span class="cov0" title="0">x.BytesValueEmpties = [][]byte{}

        // Redacting field: BytesValueNested
        for k := range x.BytesValueNested </span><span class="cov0" title="0">{
                x.BytesValueNested[k] = nil
        }</span>

        // Redacting field: BytesValues
        <span class="cov0" title="0">for k := range x.BytesValues </span><span class="cov0" title="0">{
                x.BytesValues[k] = []byte(`redacted-value-value`)
        }</span>

        // Redacting field: EnumValueEmpties
        <span class="cov0" title="0">x.EnumValueEmpties = []TestEnum{}

        // Redacting field: EnumValueNested
        for k := range x.EnumValueNested </span><span class="cov0" title="0">{
                x.EnumValueNested[k] = 0
        }</span>

        // Redacting field: EnumValues
        <span class="cov0" title="0">for k := range x.EnumValues </span><span class="cov0" title="0">{
                x.EnumValues[k] = 2
        }</span>

        // Redacting field: MessageNils
        <span class="cov0" title="0">for k := range x.MessageNils </span><span class="cov0" title="0">{
                x.MessageNils[k] = nil
        }</span>

        // Redacting field: MessageSkips
        // MessageSkips redaction is skipped

        // Redacting field: MessageNested
        <span class="cov0" title="0">for k := range x.MessageNested </span><span class="cov0" title="0">{
                redact.Apply(x.MessageNested[k])
        }</span>

        // Redacting field: MessageEmpties
        <span class="cov0" title="0">for k := range x.MessageEmpties </span><span class="cov0" title="0">{
                x.MessageEmpties[k] = &amp;TestMessage{}
        }</span>
        <span class="cov0" title="0">return x.String()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"

        pgs "github.com/lyft/protoc-gen-star/v2"

        "github.com/menta2k/protoc-gen-redact/v3/redact/v3"
)

// processFields extracts each fields information
func (m *Module) processFields(
        field pgs.Field,
        nameWithAlias func(n pgs.Entity) string,
) *FieldData <span class="cov0" title="0">{
        // Validate field before processing
        if err := m.validateField(field); err != nil </span><span class="cov0" title="0">{
                m.Failf("Invalid field: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">typ := field.Type()
        if typ == nil </span><span class="cov0" title="0">{
                m.failWithContext(field, "field has nil type")
                return nil
        }</span>

        // Determine if field will be a pointer in generated Go code
        // In proto3, fields with explicit `optional` keyword become pointers
        // These fields are implemented as synthetic oneofs (proto3_optional)
        // Exception: bytes fields are always []byte, never *[]byte, even with explicit optional
        <span class="cov0" title="0">hasExplicitOptional := field.InOneOf() &amp;&amp; field.OneOf().IsSynthetic()
        isOptional := hasExplicitOptional &amp;&amp; typ.ProtoType() != pgs.BytesT

        flData := &amp;FieldData{
                Name:        m.ctx.Name(field).String(),
                IsMap:       typ.IsMap(),
                IsRepeated:  typ.IsRepeated(),
                IsMessage:   typ.IsEmbed(),
                IsOptional:  isOptional,
                FieldGoType: goTypeName(typ.ProtoType()),
        }
        em := typ.Embed()
        if em == nil </span><span class="cov0" title="0">{
                if ele := typ.Element(); ele != nil </span><span class="cov0" title="0">{
                        em = ele.Embed()
                }</span>
        }
        // embed message
        <span class="cov0" title="0">if em != nil </span><span class="cov0" title="0">{
                flData.EmbedMessageName = m.ctx.Name(em).String()
                flData.EmbedMessageNameWithAlias = nameWithAlias(em)
        }</span>

        <span class="cov0" title="0">_redact, fieldRules := false, &amp;redact.FieldRules{}
        // ok := m.must(field.Extension(redact.E_Redact, &amp;_redact))
        ok := m.must(field.Extension(redact.E_Value, &amp;fieldRules))

        // safe field: no option is defined
        if !ok </span><span class="cov0" title="0">{
                return flData
        }</span>

        // Validate rules before processing
        <span class="cov0" title="0">if err := m.validateRules(fieldRules, field); err != nil </span><span class="cov0" title="0">{
                m.Fail(err)
                return flData
        }</span>

        // check for custom field rules
        <span class="cov0" title="0">if fieldRules == nil || fieldRules.Values == nil </span><span class="cov0" title="0">{
                // no field rules
                if !_redact </span><span class="cov0" title="0">{
                        // and redaction is also denied
                        return flData
                }</span>
                // default rules will be used
                <span class="cov0" title="0">flData.Redact = true
                flData.RedactionValue = RedactionDefaults(
                        typ.ProtoType(),
                        typ.IsRepeated() || typ.IsMap(),
                )
                if typ.IsEmbed() </span><span class="cov0" title="0">{
                        flData.NestedEmbedCall = true
                }</span>
                <span class="cov0" title="0">return flData</span>
        }

        // custom field rules are defined, hence prefill defaults
        <span class="cov0" title="0">flData.Redact = true
        flData.RedactionValue = RedactionDefaults(
                typ.ProtoType(),
                typ.IsRepeated() || typ.IsMap(),
        )
        // custom values
        m.redactedCustomValue(flData, field, fieldRules)
        return flData</span>
}

func (m *Module) redactedCustomValue(
        flData *FieldData,
        field pgs.Field,
        fieldRules *redact.FieldRules,
) <span class="cov0" title="0">{
        // Validate inputs
        if flData == nil </span><span class="cov0" title="0">{
                m.Failf("Internal error: nil FieldData for field %s", field.FullyQualifiedName())
                return
        }</span>
        <span class="cov0" title="0">if fieldRules == nil </span><span class="cov0" title="0">{
                m.Failf("Internal error: nil fieldRules for field %s", field.FullyQualifiedName())
                return
        }</span>

        <span class="cov0" title="0">typ := field.Type()
        if typ == nil </span><span class="cov0" title="0">{
                m.failWithContext(field, "field type is nil")
                return
        }</span>

        // extract rule information
        <span class="cov0" title="0">info := m.RuleInformation(fieldRules)

        // match field types &amp; rule types with better error message
        if info.ProtoType != 0 &amp;&amp; info.ProtoType != typ.ProtoType() </span><span class="cov0" title="0">{
                err := m.validateTypeMatch(field, info.ProtoType, info.ProtoLabel)
                if err != nil </span><span class="cov0" title="0">{
                        m.Fail(err)
                }</span> else<span class="cov0" title="0"> {
                        m.failWithInvalidType(field)
                }</span>
                <span class="cov0" title="0">return</span> // unreachable
        }
        <span class="cov0" title="0">if typ.ProtoLabel() == pgs.Repeated &amp;&amp; info.ProtoLabel != pgs.Repeated </span><span class="cov0" title="0">{
                err := m.validateTypeMatch(field, info.ProtoType, info.ProtoLabel)
                if err != nil </span><span class="cov0" title="0">{
                        m.Fail(err)
                }</span> else<span class="cov0" title="0"> {
                        m.failWithInvalidType(field)
                }</span>
                <span class="cov0" title="0">return</span> // unreachable
        }
        <span class="cov0" title="0">if info.ProtoType != pgs.MessageT &amp;&amp; info.ProtoLabel != pgs.Repeated </span><span class="cov0" title="0">{
                // simple type fields
                flData.RedactionValue = fmt.Sprintf("%v", info.RedactionValue)
                return
        }</span>

        // if message type
        <span class="cov0" title="0">if info.ProtoType == pgs.MessageT </span><span class="cov0" title="0">{
                rule := fieldRules.Values.(*redact.FieldRules_Message).Message
                // default value is nil
                flData.RedactionValue = `nil`
                if rule.Empty </span><span class="cov0" title="0">{
                        // flData.RedactionValue = m.ctx.Type(field).String() + "{}"
                        flData.RedactionValue = fmt.Sprintf("&amp;%s{}", flData.EmbedMessageNameWithAlias)
                        return
                }</span>
                <span class="cov0" title="0">if rule.Nil </span><span class="cov0" title="0">{
                        flData.RedactionValue = "nil"
                        return
                }</span>
                <span class="cov0" title="0">if rule.Skip </span><span class="cov0" title="0">{
                        flData.EmbedSkip = true
                        return
                }</span>
                <span class="cov0" title="0">flData.NestedEmbedCall = true
                return</span>
        }

        // else info.ProtoLabel == pgs.Repeated
        <span class="cov0" title="0">rule := fieldRules.Values.(*redact.FieldRules_Element).Element
        if rule.Empty </span><span class="cov0" title="0">{
                if flData.EmbedMessageNameWithAlias == "" </span><span class="cov0" title="0">{
                        flData.RedactionValue = m.ctx.Type(field).String() + "{}"
                        return
                }</span>
                <span class="cov0" title="0">if flData.IsRepeated </span><span class="cov0" title="0">{
                        flData.RedactionValue = fmt.Sprintf("[]*%s{}", flData.EmbedMessageNameWithAlias)
                        return
                }</span>
                // map type
                <span class="cov0" title="0">key := m.ctx.Type(field).Key().String()
                flData.RedactionValue = fmt.Sprintf("map[%s]*%s{}", key, flData.EmbedMessageNameWithAlias)
                return</span>
        }
        <span class="cov0" title="0">if rule.Nested </span><span class="cov0" title="0">{
                // iterate over all items and redact with defaults
                flData.Iterate = true
                flData.RedactionValue = RedactionDefaults(typ.Element().ProtoType(), false)
                if typ.Element().IsEmbed() </span><span class="cov0" title="0">{
                        flData.NestedEmbedCall = true
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if rules := rule.Item; rules != nil &amp;&amp; rules.Values != nil </span><span class="cov0" title="0">{
                if rules.GetElement() != nil </span><span class="cov0" title="0">{
                        // Use the improved error message
                        m.failWithNestedError(field)
                        return
                }</span>
                <span class="cov0" title="0">info := m.RuleInformation(rules)
                // match types
                if info.ProtoType != typ.Element().ProtoType() </span><span class="cov0" title="0">{
                        m.failWithInvalidType(field)
                        return // unreachable
                }</span>
                // default value is nil
                <span class="cov0" title="0">flData.Iterate = true
                flData.RedactionValue = "nil"
                if info.ProtoType != pgs.MessageT </span><span class="cov0" title="0">{
                        // simple type fields
                        flData.RedactionValue = fmt.Sprintf("%v", info.RedactionValue)
                }</span> else<span class="cov0" title="0"> {
                        // message type embedded field
                        rule := rules.Values.(*redact.FieldRules_Message).Message
                        flData.RedactionValue = `nil`
                        if rule.Empty </span><span class="cov0" title="0">{
                                // flData.RedactionValue = m.ctx.Type(field).String() + "{}"
                                flData.RedactionValue = fmt.Sprintf("&amp;%s{}", flData.EmbedMessageNameWithAlias)
                                return
                        }</span>
                        <span class="cov0" title="0">if rule.Nil </span><span class="cov0" title="0">{
                                flData.RedactionValue = "nil"
                                return
                        }</span>
                        <span class="cov0" title="0">if rule.Skip </span><span class="cov0" title="0">{
                                flData.EmbedSkip = true
                                return
                        }</span>
                        <span class="cov0" title="0">flData.NestedEmbedCall = true</span>
                }
        }
}

// RuleInfo response type for Module.RuleInformation
type RuleInfo struct {
        RedactionValue interface{}
        // equivalent field type information
        ProtoType  pgs.ProtoType
        ProtoLabel pgs.ProtoLabel
}

// RuleInformation returns required information from the redact.FieldRules
func (m *Module) RuleInformation(rules *redact.FieldRules) (res RuleInfo) <span class="cov10" title="23">{
        // custom rules validation and values
        switch rule := rules.Values.(type) </span>{
        case *redact.FieldRules_Float:<span class="cov1" title="1">
                res.ProtoType = pgs.FloatT
                res.RedactionValue = rule.Float</span>
        case *redact.FieldRules_Double:<span class="cov1" title="1">
                res.ProtoType = pgs.DoubleT
                res.RedactionValue = rule.Double</span>
        case *redact.FieldRules_Int32:<span class="cov1" title="1">
                res.ProtoType = pgs.Int32T
                res.RedactionValue = rule.Int32</span>
        case *redact.FieldRules_Int64:<span class="cov1" title="1">
                res.ProtoType = pgs.Int64T
                res.RedactionValue = rule.Int64</span>
        case *redact.FieldRules_Uint32:<span class="cov1" title="1">
                res.ProtoType = pgs.UInt32T
                res.RedactionValue = rule.Uint32</span>
        case *redact.FieldRules_Uint64:<span class="cov1" title="1">
                res.ProtoType = pgs.UInt64T
                res.RedactionValue = rule.Uint64</span>
        case *redact.FieldRules_Sint32:<span class="cov1" title="1">
                res.ProtoType = pgs.SInt32
                res.RedactionValue = rule.Sint32</span>
        case *redact.FieldRules_Sint64:<span class="cov1" title="1">
                res.ProtoType = pgs.SInt64
                res.RedactionValue = rule.Sint64</span>
        case *redact.FieldRules_Fixed32:<span class="cov1" title="1">
                res.ProtoType = pgs.Fixed32T
                res.RedactionValue = rule.Fixed32</span>
        case *redact.FieldRules_Fixed64:<span class="cov1" title="1">
                res.ProtoType = pgs.Fixed64T
                res.RedactionValue = rule.Fixed64</span>
        case *redact.FieldRules_Sfixed32:<span class="cov1" title="1">
                res.ProtoType = pgs.SFixed32
                res.RedactionValue = rule.Sfixed32</span>
        case *redact.FieldRules_Sfixed64:<span class="cov1" title="1">
                res.ProtoType = pgs.SFixed64
                res.RedactionValue = rule.Sfixed64</span>
        case *redact.FieldRules_Bool:<span class="cov2" title="2">
                res.ProtoType = pgs.BoolT
                res.RedactionValue = rule.Bool</span>
        case *redact.FieldRules_String_:<span class="cov1" title="1">
                res.ProtoType = pgs.StringT
                res.RedactionValue = fmt.Sprintf("`%v`", rule.String_)</span>
        case *redact.FieldRules_Bytes:<span class="cov1" title="1">
                res.ProtoType = pgs.BytesT
                res.RedactionValue = fmt.Sprintf("[]byte(`%v`)", string(rule.Bytes))</span>
        case *redact.FieldRules_Enum:<span class="cov1" title="1">
                res.ProtoType = pgs.EnumT
                res.RedactionValue = rule.Enum</span>
        case *redact.FieldRules_Message:<span class="cov4" title="4">
                res.ProtoType = pgs.MessageT
                if rule == nil || rule.Message == nil </span><span class="cov0" title="0">{
                        m.Fail("(redact.custom).message is nil, no option defined")
                        return // unreachable
                }</span>
        case *redact.FieldRules_Element:<span class="cov2" title="2">
                res.ProtoLabel = pgs.Repeated
                if rule == nil || rule.Element == nil </span><span class="cov0" title="0">{
                        m.Fail("(redact.custom).element is nil, no option defined")
                        return // unreachable
                }</span>
        default:<span class="cov0" title="0">
                m.Fail("Something went wrong")</span>
        }
        <span class="cov10" title="23">return res</span>
}

// goTypeName returns the Go type name for a proto type
func goTypeName(pt pgs.ProtoType) string <span class="cov0" title="0">{
        switch pt </span>{
        case pgs.Int32T:<span class="cov0" title="0">
                return "int32"</span>
        case pgs.Int64T:<span class="cov0" title="0">
                return "int64"</span>
        case pgs.UInt32T:<span class="cov0" title="0">
                return "uint32"</span>
        case pgs.UInt64T:<span class="cov0" title="0">
                return "uint64"</span>
        case pgs.SInt32:<span class="cov0" title="0">
                return "int32"</span>
        case pgs.SInt64:<span class="cov0" title="0">
                return "int64"</span>
        case pgs.Fixed32T:<span class="cov0" title="0">
                return "uint32"</span>
        case pgs.Fixed64T:<span class="cov0" title="0">
                return "uint64"</span>
        case pgs.SFixed32:<span class="cov0" title="0">
                return "int32"</span>
        case pgs.SFixed64:<span class="cov0" title="0">
                return "int64"</span>
        case pgs.FloatT:<span class="cov0" title="0">
                return "float32"</span>
        case pgs.DoubleT:<span class="cov0" title="0">
                return "float64"</span>
        case pgs.BoolT:<span class="cov0" title="0">
                return "bool"</span>
        case pgs.StringT:<span class="cov0" title="0">
                return "string"</span>
        case pgs.BytesT:<span class="cov0" title="0">
                return "[]byte"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "strconv"

        pgs "github.com/lyft/protoc-gen-star/v2"
)

// importPaths extracts all the imports of the proto files and assign them
// unique alias for imports
func (m *Module) importPaths(file pgs.File) (path2Alias, alias2Path map[string]string) <span class="cov0" title="0">{
        // Add panic recovery
        defer m.recoverFromPanic("processing import paths")

        // Validate file
        if file == nil </span><span class="cov0" title="0">{
                m.Fail("Cannot process imports: file is nil")
                return nil, nil
        }</span>

        // Initialize standard imports
        <span class="cov0" title="0">path2Alias = map[string]string{
                "context":                                           "context",
                "google.golang.org/grpc":                            "grpc",
                "google.golang.org/grpc/codes":                      "codes",
                "google.golang.org/grpc/status":                     "status",
                "github.com/menta2k/protoc-gen-redact/v3/redact/v3": "redact",
        }
        alias2Path = map[string]string{
                "context": "context",
                "grpc":    "google.golang.org/grpc",
                "codes":   "google.golang.org/grpc/codes",
                "status":  "google.golang.org/grpc/status",
                "redact":  "github.com/menta2k/protoc-gen-redact/v3/redact/v3",
        }

        self := m.ctx.ImportPath(file).String()

        // Validate import path
        if err := m.validateImportPath(self); err != nil </span><span class="cov0" title="0">{
                m.Failf("Invalid file import path: %v", err)
                return path2Alias, alias2Path
        }</span>
        <span class="cov0" title="0">for _, imp := range file.Imports() </span><span class="cov0" title="0">{
                // Validate import
                if imp == nil </span><span class="cov0" title="0">{
                        m.Debug("Skipping nil import")
                        continue</span>
                }

                <span class="cov0" title="0">path := m.ctx.ImportPath(imp).String()

                // Validate import path
                if err := m.validateImportPath(path); err != nil </span><span class="cov0" title="0">{
                        m.Debug(fmt.Sprintf("Skipping invalid import path: %v", err))
                        continue</span>
                }

                <span class="cov0" title="0">if self == path </span><span class="cov0" title="0">{
                        // Skip self-imports
                        continue</span>
                }
                <span class="cov0" title="0">if _, ok := path2Alias[path]; ok </span><span class="cov0" title="0">{
                        // already exist
                        continue</span>
                }

                // Only add imports that contain messages, enums, or services that might be used
                // Skip imports that only provide annotations or are metadata-only
                <span class="cov0" title="0">hasUsableTypes := len(imp.AllMessages()) &gt; 0 || len(imp.AllEnums()) &gt; 0 || len(imp.Services()) &gt; 0
                if !hasUsableTypes </span><span class="cov0" title="0">{
                        m.Debug(fmt.Sprintf("Skipping import %s: no usable types", path))
                        continue</span>
                }

                <span class="cov0" title="0">alias := m.ctx.PackageName(imp).String()

                // Validate package name
                if err := m.validatePackageName(alias); err != nil </span><span class="cov0" title="0">{
                        m.Debug(fmt.Sprintf("Skipping import with invalid package name %s: %v", alias, err))
                        continue</span>
                }

                <span class="cov0" title="0">_, ok := alias2Path[alias]
                cnt := 0
                for ok </span><span class="cov0" title="0">{
                        cnt++
                        _, ok = alias2Path[alias+strconv.Itoa(cnt)]
                }</span>
                <span class="cov0" title="0">if cnt &gt; 0 </span><span class="cov0" title="0">{
                        alias = alias + strconv.Itoa(cnt)
                        m.Debug(fmt.Sprintf("Resolved import alias conflict: %s -&gt; %s", path, alias))
                }</span>
                <span class="cov0" title="0">path2Alias[path] = alias
                alias2Path[alias] = path</span>
        }
        <span class="cov0" title="0">return</span>
}

// references lists all the import-references from different proto packages
// to suppress any unused import errors
func (m *Module) references(file pgs.File, nameWithAlias func(n pgs.Entity) string) []string <span class="cov0" title="0">{
        // Add panic recovery
        defer m.recoverFromPanic("processing import references")

        // Validate file
        if file == nil </span><span class="cov0" title="0">{
                m.Debug("Cannot generate references: file is nil")
                return []string{}
        }</span>

        <span class="cov0" title="0">imports := file.Imports()
        list := make([]string, 0, len(imports)+5)

        // Add standard references
        list = append(list, "grpc.Server",
                "context.Context",
                "redact.Redactor",
                "codes.Code",
                "status.Status",
        )

        self := m.ctx.ImportPath(file)
        for _, imp := range imports </span><span class="cov0" title="0">{
                // Validate import
                if imp == nil </span><span class="cov0" title="0">{
                        m.Debug("Skipping nil import in references")
                        continue</span>
                }

                <span class="cov0" title="0">if m.ctx.ImportPath(imp) == self </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Only reference imports that have usable types
                // This matches the filter in importPaths()
                <span class="cov0" title="0">hasUsableTypes := len(imp.AllMessages()) &gt; 0 || len(imp.AllEnums()) &gt; 0 || len(imp.Services()) &gt; 0
                if !hasUsableTypes </span><span class="cov0" title="0">{
                        continue</span>
                }

                // messages
                <span class="cov0" title="0">msgL := imp.AllMessages()
                if len(msgL) &gt; 0 </span><span class="cov0" title="0">{
                        if msgL[0] != nil </span><span class="cov0" title="0">{
                                list = append(list, nameWithAlias(msgL[0]))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                // or enums
                <span class="cov0" title="0">enmL := imp.AllEnums()
                if len(enmL) &gt; 0 </span><span class="cov0" title="0">{
                        if enmL[0] != nil </span><span class="cov0" title="0">{
                                list = append(list, nameWithAlias(enmL[0]))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                // or services
                <span class="cov0" title="0">srvL := imp.Services()
                if len(srvL) &gt; 0 </span><span class="cov0" title="0">{
                        if srvL[0] != nil </span><span class="cov0" title="0">{
                                list = append(list, nameWithAlias(srvL[0]))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        <span class="cov0" title="0">m.Debug(fmt.Sprintf("Generated %d import references", len(list)))
        return list</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        pgs "github.com/lyft/protoc-gen-star/v2"
        pgsGo "github.com/lyft/protoc-gen-star/v2/lang/go"
        "google.golang.org/protobuf/types/pluginpb"
)

func main() <span class="cov0" title="0">{
        optionalFeature := uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

        pgs.Init(pgs.DebugEnv("DEBUG_PGR"), pgs.SupportedFeatures(&amp;optionalFeature)).
                RegisterModule(Redactor()).
                RegisterPostProcessor(pgsGo.GoFmt()).
                Render()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "os"
        "path/filepath"
        "text/template"

        pgs "github.com/lyft/protoc-gen-star/v2"
        pgsGo "github.com/lyft/protoc-gen-star/v2/lang/go"
)

// Redactor returns the implementation of the protoc-gen-redact plugin
// to generate redaction file
func Redactor() pgs.Module <span class="cov0" title="0">{ return &amp;Module{ModuleBase: &amp;pgs.ModuleBase{}} }</span>

// Module implements the pgs.Module interface for protoc-gen-redact plugin
type Module struct {
        *pgs.ModuleBase
        ctx  pgsGo.Context
        tmpl *template.Template
}

// Name...
func (*Module) Name() string <span class="cov1" title="1">{ return "redactor" }</span>

// InitContext satisfies the pgs.Module interface and helps build the module
func (m *Module) InitContext(c pgs.BuildContext) <span class="cov0" title="0">{
        // Add panic recovery for initialization
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        m.Failf("Panic during module initialization: %v", r)
                }</span>
        }()

        <span class="cov0" title="0">m.ModuleBase.InitContext(c)
        m.ctx = pgsGo.InitContext(c.Parameters())

        // Validate context
        if m.ctx == nil </span><span class="cov0" title="0">{
                m.Fail("Failed to initialize Go context")
                return
        }</span>

        // Check for custom template file parameter
        <span class="cov0" title="0">templateFile := c.Parameters().Str("template_file")

        tpl := template.New("redact").Funcs(map[string]interface{}{
                "package": m.ctx.PackageName,
                "name":    m.ctx.Name,
        })

        var parsedTpl *template.Template
        var err error

        if templateFile != "" </span><span class="cov0" title="0">{
                // Load template from external file
                m.Debug("Loading template from file: " + templateFile)
                parsedTpl, err = m.loadTemplateFromFile(tpl, templateFile)
                if err != nil </span><span class="cov0" title="0">{
                        m.Failf("Failed to load template from file %s: %v", templateFile, err)
                        return
                }</span>
                <span class="cov0" title="0">m.Debug("Successfully loaded external template")</span>
        } else<span class="cov0" title="0"> {
                // Use embedded template
                m.Debug("Using embedded template")
                parsedTpl, err = tpl.Parse(redactTpl)
                if err != nil </span><span class="cov0" title="0">{
                        m.Failf("Failed to parse embedded template: %v", err)
                        return
                }</span>
        }

        <span class="cov0" title="0">m.tmpl = parsedTpl
        m.Debug("Module initialized successfully")</span>
}

// Execute satisfies the pgs.Module interface &amp; generates the redactor file
// for the targeted files
func (m *Module) Execute(targets map[string]pgs.File, _ map[string]pgs.Package) []pgs.Artifact <span class="cov0" title="0">{
        // process all the target files
        for _, file := range targets </span><span class="cov0" title="0">{
                m.Process(file)
        }</span>
        <span class="cov0" title="0">return m.Artifacts()</span>
}

// loadTemplateFromFile loads a template from an external file
func (m *Module) loadTemplateFromFile(tpl *template.Template, templatePath string) (*template.Template, error) <span class="cov10" title="2">{
        // Validate the file path
        if templatePath == "" </span><span class="cov1" title="1">{
                return nil, ErrorContext{
                        Location: "template_file parameter",
                        Reason:   "template file path is empty",
                }
        }</span>

        // Resolve absolute path
        <span class="cov1" title="1">absPath, err := filepath.Abs(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorContext{
                        Location: "template_file: " + templatePath,
                        Reason:   "failed to resolve absolute path: " + err.Error(),
                }
        }</span>

        // Check if file exists
        <span class="cov1" title="1">fileInfo, err := os.Stat(absPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, ErrorContext{
                                Location: "template_file: " + absPath,
                                Reason:   "file does not exist",
                        }
                }</span>
                <span class="cov0" title="0">return nil, ErrorContext{
                        Location: "template_file: " + absPath,
                        Reason:   "failed to stat file: " + err.Error(),
                }</span>
        }

        // Check if it's a regular file
        <span class="cov1" title="1">if !fileInfo.Mode().IsRegular() </span><span class="cov1" title="1">{
                return nil, ErrorContext{
                        Location: "template_file: " + absPath,
                        Reason:   "path is not a regular file",
                }
        }</span>

        // Check file size (limit to 10MB for safety)
        <span class="cov0" title="0">const maxTemplateSize = 10 * 1024 * 1024 // 10MB
        if fileInfo.Size() &gt; maxTemplateSize </span><span class="cov0" title="0">{
                return nil, ErrorContext{
                        Location: "template_file: " + absPath,
                        Reason:   "template file is too large (max 10MB)",
                }
        }</span>

        // Read the template file
        <span class="cov0" title="0">templateContent, err := os.ReadFile(absPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorContext{
                        Location: "template_file: " + absPath,
                        Reason:   "failed to read file: " + err.Error(),
                }
        }</span>

        // Parse the template
        <span class="cov0" title="0">parsedTpl, err := tpl.Parse(string(templateContent))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrorContext{
                        Location: "template_file: " + absPath,
                        Reason:   "failed to parse template: " + err.Error(),
                }
        }</span>

        <span class="cov0" title="0">m.Debug("Template loaded successfully from: " + absPath)
        return parsedTpl, nil</span>
}

const redactTpl = `{{ $data := . }}
// Code generated by protoc-gen-redact. DO NOT EDIT.
// source: {{ $data.Source }}

package {{ $data.Package }}

import (
        {{- range $alias, $path := $data.Imports }}
        {{ $alias }} "{{ $path }}"
        {{- end }}
)

// Reference imports to suppress errors if they are not otherwise used.
var (
        {{- range $name := $data.References }}
        _ {{ $name }}
        {{- end }}
)

{{ range $srv := $data.Services }}
        {{- if $srv.Skip }}
                // Redacted server wrapper for {{ $srv.Name }} is skipped
                var RegisterRedacted{{ $srv.Name }} = Register{{ $srv.Name }}
        {{- else }}
                // RegisterRedacted{{ $srv.Name }} wraps the {{ $srv.Name }} with the redacted server and registers the service in GRPC
                func RegisterRedacted{{ $srv.Name }}(s grpc.ServiceRegistrar, srv {{ $srv.Name }}, bypass redact.Bypass) {
                        Register{{ $srv.Name }}(s, Redacted{{ $srv.Name }}(srv, bypass))
                }

                func Redacted{{ $srv.Name }}(srv {{ $srv.Name }}, bypass redact.Bypass) {{ $srv.Name }} {
                        if bypass == nil {
                                bypass = redact.Falsy
                        }
                        return &amp;redacted{{ $srv.Name }}{srv: srv, bypass: bypass}
                }

                type redacted{{ $srv.Name }} struct {
                        Unsafe{{ $srv.Name }}
                        srv    {{ $srv.Name }}
                        bypass redact.Bypass
                }

                {{ range $meth := $srv.Methods }}
                        // {{ $meth.Name }} is the redacted wrapper for the actual {{ $srv.Name }}.{{ $meth.Name }} method
                        {{- if and $meth.ClientStreaming $meth.ServerStreaming }}
                                // Bidirectional streaming
                                func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(stream grpc.BidiStreamingServer[{{ $meth.Input }}, {{ $meth.Output.WithAlias }}]) error {
                                        {{- if $meth.Skip }}
                                                // Redaction skipped
                                                return s.srv.{{ $meth.Name }}(stream)
                                        {{- else }}
                                                // Note: Redaction for bidirectional streaming is not fully implemented
                                                // Streaming methods pass through without redaction
                                                return s.srv.{{ $meth.Name }}(stream)
                                        {{- end }}
                                }
                        {{- else if $meth.ClientStreaming }}
                                // Client streaming
                                func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(stream grpc.ClientStreamingServer[{{ $meth.Input }}, {{ $meth.Output.WithAlias }}]) error {
                                        {{- if $meth.Skip }}
                                                // Redaction skipped
                                                return s.srv.{{ $meth.Name }}(stream)
                                        {{- else }}
                                                // Note: Redaction for client streaming is not fully implemented
                                                // Streaming methods pass through without redaction
                                                return s.srv.{{ $meth.Name }}(stream)
                                        {{- end }}
                                }
                        {{- else if $meth.ServerStreaming }}
                                // Server streaming
                                func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(in *{{ $meth.Input }}, stream grpc.ServerStreamingServer[{{ $meth.Output.WithAlias }}]) error {
                                        {{- if $meth.Skip }}
                                                // Redaction skipped
                                                return s.srv.{{ $meth.Name }}(in, stream)
                                        {{- else }}
                                                // Note: Redaction for server streaming is not fully implemented
                                                // Streaming methods pass through without redaction
                                                return s.srv.{{ $meth.Name }}(in, stream)
                                        {{- end }}
                                }
                        {{- else }}
                                // Unary RPC
                                func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(ctx context.Context, in *{{ $meth.Input }}) (*{{ $meth.Output.WithAlias }}, error) {
                                        {{- if $meth.Skip }}
                                                // Redaction skipped
                                                return s.srv.{{ $meth.Name }}(ctx, in)
                                        {{- else if $meth.Internal }}
                                                if s.bypass.CheckInternal(ctx) {
                                                        return s.srv.{{ $meth.Name }}(ctx, in)
                                                }
                                                return nil, status.Error(codes.{{ $meth.StatusCode }}, {{ $meth.ErrMessage }})
                                        {{- else }}
                                                res, err := s.srv.{{ $meth.Name }}(ctx, in)
                                                if !s.bypass.CheckInternal(ctx) {
                                                        {{- if $meth.Output.ToNil }}
                                                                // Response message is set to nil, ignoring all field level rules
                                                                res = nil
                                                        {{- else if $meth.Output.ToEmpty }}
                                                                // Response message is set to empty, ignoring all field level rules
                                                                res = &amp;{{ $meth.Output.WithAlias }}{}
                                                        {{- else if $meth.Output.Ignore  }}
                                                                // Response message is set to be ignored from any redaction
                                                        {{- else }}
                                                                // Apply redaction to the response
                                                                redact.Apply(res)
                                                        {{- end }}
                                                }
                                                return res, err
                                        {{- end }}
                                }
                        {{- end }}
                {{ end }}
        {{ end }}
{{ end }}

{{ range $msg := $data.Messages }}
        // Redact method implementation for {{ $msg.Name }}
        func (x *{{ $msg.Name }}) Redact() string {
                {{- if $msg.Ignore }}
                        // Ignoring message
                {{- else if $msg.ToEmpty }}
                        // Message will be set to empty, ignoring all field level rules
                {{- else if $msg.ToNil }}
                        // Message will be set to nil, ignoring all field level rules
                {{- else }}
                        if x == nil { return "" }
                        {{- range $field := $msg.Fields }}
                                {{ if $field.Redact }}
                                        // Redacting field: {{ $field.Name }}
                                        {{- if $field.Iterate }}
                                                {{- if $field.NestedEmbedCall }}
                                                        for k := range x.{{ $field.Name }} {
                                                                redact.Apply(x.{{$field.Name}}[k])
                                                        }
                                                {{- else if $field.EmbedSkip }}
                                                        // {{$field.Name}} redaction is skipped
                        {{- else }}
                                                        for k := range x.{{ $field.Name }} {
                                                                x.{{ $field.Name }}[k] = {{ $field.RedactionValue }}
                                                        }
                                                {{- end }}
                    {{- else if $field.IsMessage }}
                                                {{- if $field.NestedEmbedCall }}
                                                        redact.Apply(x.{{$field.Name}})
                                                {{- else if $field.EmbedSkip }}
                                                        // {{$field.Name}} redaction is skipped
                        {{- else }}
                                                        x.{{ $field.Name }} = {{ $field.RedactionValue }}
                                                {{- end }}
                    {{- else }}
                                                {{- if $field.IsOptional }}
                                                        {{- if eq $field.FieldGoType "string" }}
                                                                {{ $field.Name }}Tmp := {{ $field.RedactionValue }}
                                                                x.{{ $field.Name }} = &amp;{{ $field.Name }}Tmp
                                                        {{- else }}
                                                                {{ $field.Name }}Tmp := {{ $field.FieldGoType }}({{ $field.RedactionValue }})
                                                                x.{{ $field.Name }} = &amp;{{ $field.Name }}Tmp
                                                        {{- end }}
                                                {{- else }}
                                                        x.{{ $field.Name }} = {{ $field.RedactionValue }}
                                                {{- end }}
                                        {{- end }}
                                {{- else }}
                                        // Safe field: {{ $field.Name }}
                                {{- end }}
                        {{- end }}
                {{- end }}
    return x.String()
        }
{{ end }}
`
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "fmt"
        "strings"

        pgs "github.com/lyft/protoc-gen-star/v2"
        "google.golang.org/grpc/codes"

        "github.com/menta2k/protoc-gen-redact/v3/redact/v3"
)

const (
        // invalidCodeErrMsg: 0 &lt;= grpc status code &lt;= 16
        // Reference: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
        invalidCodeErrMsg = `InternalStatusCode must be a valid GRPC code(0 &lt;= code &lt;= 16)`
        // defaultErrMsg: for the service method/rpc redaction
        defaultErrMsg = `Permission Denied. Method: "%service%.%method%" has been redacted`
        // error message format specifiers
        specifierMethod  = "%method%"
        specifierService = "%service%"
)

// Process processes the file and adds its generated code into Module.Artifacts
func (m *Module) Process(file pgs.File) <span class="cov0" title="0">{
        // Validate file before processing
        if err := m.validateFile(file); err != nil </span><span class="cov0" title="0">{
                m.Failf("Cannot process file: %v", err)
                return
        }</span>

        // Add panic recovery for robustness
        <span class="cov0" title="0">defer m.recoverFromPanic(fmt.Sprintf("processing file %s", file.Name()))

        // check file option: FileSkip
        fileSkip := false
        m.must(file.Extension(redact.E_FileSkip, &amp;fileSkip))
        if fileSkip </span><span class="cov0" title="0">{
                m.Debug(fmt.Sprintf("Skipping file %s due to file_skip option", file.Name()))
                return
        }</span>

        // imports and their aliases
        <span class="cov0" title="0">path2Alias, alias2Path := m.importPaths(file)
        nameWithAlias := func(n pgs.Entity) string </span><span class="cov0" title="0">{
                imp := m.ctx.ImportPath(n).String()
                name := m.ctx.Name(n).String()
                if alias := path2Alias[imp]; alias != "" </span><span class="cov0" title="0">{
                        name = alias + "." + name
                }</span>
                <span class="cov0" title="0">return name</span>
        }

        <span class="cov0" title="0">data := &amp;ProtoFileData{
                Source:     file.Name().String(),
                Package:    m.ctx.PackageName(file).String(),
                Imports:    alias2Path,
                References: m.references(file, nameWithAlias),
                Services:   make([]*ServiceData, 0, len(file.Services())),
                Messages:   make([]*MessageData, 0, len(file.AllMessages())),
        }

        // all services
        for _, srv := range file.Services() </span><span class="cov0" title="0">{
                data.Services = append(data.Services, m.processService(srv, nameWithAlias))
        }</span>

        // all messages
        <span class="cov0" title="0">for _, msg := range file.AllMessages() </span><span class="cov0" title="0">{
                data.Messages = append(data.Messages, m.processMessage(msg, nameWithAlias, true))
        }</span>

        // render file in the template
        <span class="cov0" title="0">name := m.ctx.OutputPath(file).SetExt(".redact.go")
        m.AddGeneratorTemplateFile(name.String(), m.tmpl, data)</span>
}

// processService extracts all pgs.Service and their pgs.Method(s) information and
// structures them into ServiceData
func (m *Module) processService(
        srv pgs.Service,
        nameWithAlias func(n pgs.Entity) string,
) *ServiceData <span class="cov0" title="0">{
        // Validate service before processing
        if err := m.validateService(srv); err != nil </span><span class="cov0" title="0">{
                m.Failf("Cannot process service: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">defer m.recoverFromPanic(fmt.Sprintf("processing service %s", srv.FullyQualifiedName()))

        srvData := &amp;ServiceData{
                Name:    m.ctx.Name(srv).String(),
                Methods: make([]*MethodData, 0, len(srv.Methods())),
        }

        // check service option: ServiceSkip
        srvSkip := false
        m.must(srv.Extension(redact.E_ServiceSkip, &amp;srvSkip))
        if srvSkip </span><span class="cov0" title="0">{
                srvData.Skip = true
                m.Debug(fmt.Sprintf("Service %s is marked as skipped", srv.FullyQualifiedName()))
                // continue
        }</span>

        // check internal service options
        <span class="cov0" title="0">srvInternal := false
        m.must(srv.Extension(redact.E_InternalService, &amp;srvInternal))
        srvCode := uint32(codes.PermissionDenied) // default code
        if !m.must(srv.Extension(redact.E_InternalServiceCode, &amp;srvCode)) </span><span class="cov0" title="0">{
                srvCode = uint32(codes.PermissionDenied)
        }</span>

        // Validate status code with better error message
        <span class="cov0" title="0">if err := m.validateStatusCode(srvCode, srv.FullyQualifiedName()); err != nil </span><span class="cov0" title="0">{
                m.Fail(err)
                return nil
        }</span>
        <span class="cov0" title="0">srvErrMsg := ""
        if !m.must(srv.Extension(redact.E_InternalServiceErrMessage, &amp;srvErrMsg)) </span><span class="cov0" title="0">{
                srvErrMsg = defaultErrMsg
        }</span>

        // methods
        <span class="cov0" title="0">for _, meth := range srv.Methods() </span><span class="cov0" title="0">{
                // Validate method before processing
                if err := m.validateMethod(meth); err != nil </span><span class="cov0" title="0">{
                        m.Failf("Cannot process method %s: %v", meth.FullyQualifiedName(), err)
                        continue</span>
                }

                <span class="cov0" title="0">in := meth.Input()
                out := meth.Output()

                // Additional safety checks
                if in == nil </span><span class="cov0" title="0">{
                        m.Failf("Method %s has nil input message", meth.FullyQualifiedName())
                        continue</span>
                }
                <span class="cov0" title="0">if out == nil </span><span class="cov0" title="0">{
                        m.Failf("Method %s has nil output message", meth.FullyQualifiedName())
                        continue</span>
                }

                <span class="cov0" title="0">methData := &amp;MethodData{
                        Name:            m.ctx.Name(meth).String(),
                        Input:           nameWithAlias(in),
                        Output:          m.processMessage(out, nameWithAlias),
                        ClientStreaming: meth.ClientStreaming(),
                        ServerStreaming: meth.ServerStreaming(),
                }
                srvData.Methods = append(srvData.Methods, methData)

                // check method skip options
                methSkip := false
                m.must(meth.Extension(redact.E_MethodSkip, &amp;methSkip))
                if methSkip || srvSkip </span><span class="cov0" title="0">{
                        methData.Skip = true
                        if methSkip </span><span class="cov0" title="0">{
                                m.Debug(fmt.Sprintf("Method %s is marked as skipped", meth.FullyQualifiedName()))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">methInternal := false
                m.must(meth.Extension(redact.E_InternalMethod, &amp;methInternal))
                methCode := srvCode // serviceCode
                if !m.must(meth.Extension(redact.E_InternalMethodCode, &amp;methCode)) </span><span class="cov0" title="0">{
                        methCode = srvCode
                }</span>

                // Validate method status code with better error message
                <span class="cov0" title="0">if err := m.validateStatusCode(methCode, meth.FullyQualifiedName()); err != nil </span><span class="cov0" title="0">{
                        m.Fail(err)
                        continue</span>
                }
                <span class="cov0" title="0">methErrMsg := srvErrMsg
                if !m.must(meth.Extension(redact.E_InternalMethodErrMessage, &amp;methErrMsg)) </span><span class="cov0" title="0">{
                        methErrMsg = srvErrMsg
                }</span>

                // apply format specifiers
                <span class="cov0" title="0">methErrMsg = strings.ReplaceAll(methErrMsg, specifierMethod, methData.Name)
                methErrMsg = strings.ReplaceAll(methErrMsg, specifierService, srvData.Name)

                methData.ErrMessage = "`" + methErrMsg + "`"
                methData.StatusCode = codes.Code(methCode).String()
                methData.Internal = srvInternal || methInternal</span>
        }
        <span class="cov0" title="0">return srvData</span>
}

// processMessage extracts all pgs.Message and their pgs.Field(s) information and
// structures them into MessageData
func (m *Module) processMessage(
        msg pgs.Message,
        nameWithAlias func(n pgs.Entity) string,
        wantFields ...bool,
) *MessageData <span class="cov0" title="0">{
        // Validate message before processing
        if err := m.validateMessage(msg); err != nil </span><span class="cov0" title="0">{
                m.Failf("Cannot process message: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">defer m.recoverFromPanic(fmt.Sprintf("processing message %s", msg.FullyQualifiedName()))

        msgData := &amp;MessageData{
                Name:      m.ctx.Name(msg).String(),
                WithAlias: nameWithAlias(msg),
                Fields:    make([]*FieldData, 0, len(msg.Fields())*2),
        }

        // check message ignore options
        msgData.Ignore = false
        m.must(msg.Extension(redact.E_Ignored, &amp;msgData.Ignore))
        if msgData.Ignore </span><span class="cov0" title="0">{
                m.Debug(fmt.Sprintf("Message %s is marked as ignored", msg.FullyQualifiedName()))
                return msgData
        }</span>

        // check message nil options
        <span class="cov0" title="0">msgData.ToNil = false
        m.must(msg.Extension(redact.E_Nil, &amp;msgData.ToNil))

        // check message empty options
        msgData.ToEmpty = false
        m.must(msg.Extension(redact.E_Empty, &amp;msgData.ToEmpty))

        // Log warning if both nil and empty are set (validation should have caught this)
        if msgData.ToNil &amp;&amp; msgData.ToEmpty </span><span class="cov0" title="0">{
                m.Debug(fmt.Sprintf("Warning: Message %s has both nil and empty options - this is invalid", msg.FullyQualifiedName()))
        }</span>

        <span class="cov0" title="0">if len(wantFields) &gt; 0 </span><span class="cov0" title="0">{
                for _, field := range msg.Fields() </span><span class="cov0" title="0">{
                        msgData.Fields = append(msgData.Fields, m.processFields(field, nameWithAlias))
                }</span>
        }
        <span class="cov0" title="0">return msgData</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package redact provides interfaces and methods to help implement redaction.
package redact

import "context"

// Redactor provides the method to be used to Redact
type Redactor interface {
        Redact()
}

// Apply will apply redaction on the input, if it implements Redactor.
// It will do nothing if the object does not implement the interface.
func Apply(in interface{}) <span class="cov0" title="0">{
        if red, ok := in.(Redactor); ok </span><span class="cov0" title="0">{
                red.Redact()
        }</span>
}

// Bypass provides a way to bypass the internal marked methods to be ran
// through clients
type Bypass interface {
        CheckInternal(ctx context.Context) bool
}

// Wrapper helps to implement Bypass
type Wrapper func(ctx context.Context) bool

// CheckInternal for Wrapper
func (w Wrapper) CheckInternal(ctx context.Context) bool <span class="cov0" title="0">{ return w(ctx) }</span>

// Falsy is the nil implementation for Bypass
var Falsy = Wrapper(func(_ context.Context) bool <span class="cov0" title="0">{
        return false
}</span>)
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.33.0
//         protoc        v5.26.1
// source: redact/v3/redact.proto

// Package redact provides interfaces and methods to help implement redaction.

package redact

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// FieldRules encapsulates options to change the redacted values of any type of field.
// Depending on the field, the correct type value should be used.
type FieldRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // values for redacted field
        //
        // Types that are assignable to Values:
        //
        //        *FieldRules_Float
        //        *FieldRules_Double
        //        *FieldRules_Int32
        //        *FieldRules_Int64
        //        *FieldRules_Uint32
        //        *FieldRules_Uint64
        //        *FieldRules_Sint32
        //        *FieldRules_Sint64
        //        *FieldRules_Fixed32
        //        *FieldRules_Fixed64
        //        *FieldRules_Sfixed32
        //        *FieldRules_Sfixed64
        //        *FieldRules_Bool
        //        *FieldRules_String_
        //        *FieldRules_Bytes
        //        *FieldRules_Enum
        //        *FieldRules_Message
        //        *FieldRules_Element
        Values isFieldRules_Values `protobuf_oneof:"values"`
}

func (x *FieldRules) Reset() <span class="cov0" title="0">{
        *x = FieldRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_redact_v3_redact_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FieldRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FieldRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FieldRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_redact_v3_redact_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FieldRules.ProtoReflect.Descriptor instead.
func (*FieldRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_redact_v3_redact_proto_rawDescGZIP(), []int{0}
}</span>

func (m *FieldRules) GetValues() isFieldRules_Values <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetFloat() float32 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Float); ok </span><span class="cov0" title="0">{
                return x.Float
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetDouble() float64 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Double); ok </span><span class="cov0" title="0">{
                return x.Double
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetInt32() int32 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Int32); ok </span><span class="cov0" title="0">{
                return x.Int32
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetInt64() int64 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Int64); ok </span><span class="cov0" title="0">{
                return x.Int64
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetUint32() uint32 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Uint32); ok </span><span class="cov0" title="0">{
                return x.Uint32
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetUint64() uint64 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Uint64); ok </span><span class="cov0" title="0">{
                return x.Uint64
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetSint32() int32 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Sint32); ok </span><span class="cov0" title="0">{
                return x.Sint32
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetSint64() int64 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Sint64); ok </span><span class="cov0" title="0">{
                return x.Sint64
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetFixed32() uint32 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Fixed32); ok </span><span class="cov0" title="0">{
                return x.Fixed32
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetFixed64() uint64 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Fixed64); ok </span><span class="cov0" title="0">{
                return x.Fixed64
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetSfixed32() int32 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Sfixed32); ok </span><span class="cov0" title="0">{
                return x.Sfixed32
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetSfixed64() int64 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Sfixed64); ok </span><span class="cov0" title="0">{
                return x.Sfixed64
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetBool() bool <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Bool); ok </span><span class="cov0" title="0">{
                return x.Bool
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *FieldRules) GetString_() string <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_String_); ok </span><span class="cov0" title="0">{
                return x.String_
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FieldRules) GetBytes() []byte <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Bytes); ok </span><span class="cov0" title="0">{
                return x.Bytes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetEnum() int32 <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Enum); ok </span><span class="cov0" title="0">{
                return x.Enum
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FieldRules) GetMessage() *MessageRules <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Message); ok </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetElement() *ElementRules <span class="cov0" title="0">{
        if x, ok := x.GetValues().(*FieldRules_Element); ok </span><span class="cov0" title="0">{
                return x.Element
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isFieldRules_Values interface {
        isFieldRules_Values()
}

type FieldRules_Float struct {
        // Scalar Field Types values
        Float float32 `protobuf:"fixed32,2,opt,name=float,proto3,oneof"`
}

type FieldRules_Double struct {
        Double float64 `protobuf:"fixed64,3,opt,name=double,proto3,oneof"`
}

type FieldRules_Int32 struct {
        Int32 int32 `protobuf:"varint,4,opt,name=int32,proto3,oneof"`
}

type FieldRules_Int64 struct {
        Int64 int64 `protobuf:"varint,5,opt,name=int64,proto3,oneof"`
}

type FieldRules_Uint32 struct {
        Uint32 uint32 `protobuf:"varint,6,opt,name=uint32,proto3,oneof"`
}

type FieldRules_Uint64 struct {
        Uint64 uint64 `protobuf:"varint,7,opt,name=uint64,proto3,oneof"`
}

type FieldRules_Sint32 struct {
        Sint32 int32 `protobuf:"zigzag32,8,opt,name=sint32,proto3,oneof"`
}

type FieldRules_Sint64 struct {
        Sint64 int64 `protobuf:"zigzag64,9,opt,name=sint64,proto3,oneof"`
}

type FieldRules_Fixed32 struct {
        Fixed32 uint32 `protobuf:"fixed32,10,opt,name=fixed32,proto3,oneof"`
}

type FieldRules_Fixed64 struct {
        Fixed64 uint64 `protobuf:"fixed64,11,opt,name=fixed64,proto3,oneof"`
}

type FieldRules_Sfixed32 struct {
        Sfixed32 int32 `protobuf:"fixed32,12,opt,name=sfixed32,proto3,oneof"`
}

type FieldRules_Sfixed64 struct {
        Sfixed64 int64 `protobuf:"fixed64,13,opt,name=sfixed64,proto3,oneof"`
}

type FieldRules_Bool struct {
        Bool bool `protobuf:"varint,14,opt,name=bool,proto3,oneof"`
}

type FieldRules_String_ struct {
        String_ string `protobuf:"bytes,15,opt,name=string,proto3,oneof"`
}

type FieldRules_Bytes struct {
        Bytes []byte `protobuf:"bytes,16,opt,name=bytes,proto3,oneof"`
}

type FieldRules_Enum struct {
        Enum int32 `protobuf:"varint,17,opt,name=enum,proto3,oneof"`
}

type FieldRules_Message struct {
        // Message defines rules for singular message type fields only
        Message *MessageRules `protobuf:"bytes,19,opt,name=message,proto3,oneof"`
}

type FieldRules_Element struct {
        // Element defines rules for repeated or map type fields
        Element *ElementRules `protobuf:"bytes,20,opt,name=element,proto3,oneof"`
}

func (*FieldRules_Float) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Double) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Int32) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Int64) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Uint32) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Uint64) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sint32) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sint64) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Fixed32) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Fixed64) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sfixed32) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sfixed64) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Bool) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_String_) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Bytes) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Enum) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Message) isFieldRules_Values() {<span class="cov0" title="0">}</span>

func (*FieldRules_Element) isFieldRules_Values() {<span class="cov0" title="0">}</span>

// MessageRules describe the constraints applied to embedded message for redaction.
// For message-type fields, rules are performed recursively.
type MessageRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Skip specifies that the redaction rules of this field should not be evaluated
        Skip bool `protobuf:"varint,1,opt,name=skip,proto3" json:"skip,omitempty"`
        // Empty specifies that after redaction this field should be set to empty object
        Empty bool `protobuf:"varint,2,opt,name=empty,proto3" json:"empty,omitempty"`
        // Nil specifies that after redaction this field should be set to nil object
        Nil bool `protobuf:"varint,3,opt,name=nil,proto3" json:"nil,omitempty"`
        // Apply specifies that redaction is to be called for the message type
        Apply bool `protobuf:"varint,4,opt,name=apply,proto3" json:"apply,omitempty"`
}

func (x *MessageRules) Reset() <span class="cov0" title="0">{
        *x = MessageRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_redact_v3_redact_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *MessageRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MessageRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MessageRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_redact_v3_redact_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MessageRules.ProtoReflect.Descriptor instead.
func (*MessageRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_redact_v3_redact_proto_rawDescGZIP(), []int{1}
}</span>

func (x *MessageRules) GetSkip() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Skip
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MessageRules) GetEmpty() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Empty
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MessageRules) GetNil() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Nil
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MessageRules) GetApply() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Apply
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ElementRules describe the constraints applied to `repeated` or `map` values
type ElementRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Empty specifies that after redaction the list/map will be empty
        Empty bool `protobuf:"varint,1,opt,name=empty,proto3" json:"empty,omitempty"`
        // Nested specifies that default rules is to be applied `recursively` on each
        // item of map/list
        Nested bool `protobuf:"varint,2,opt,name=nested,proto3" json:"nested,omitempty"`
        // Item specifies that some custom redaction rules to be applied `recursively`
        // on each item in map/list.
        Item *FieldRules `protobuf:"bytes,3,opt,name=item,proto3" json:"item,omitempty"`
}

func (x *ElementRules) Reset() <span class="cov0" title="0">{
        *x = ElementRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_redact_v3_redact_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ElementRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ElementRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ElementRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_redact_v3_redact_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ElementRules.ProtoReflect.Descriptor instead.
func (*ElementRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_redact_v3_redact_proto_rawDescGZIP(), []int{2}
}</span>

func (x *ElementRules) GetEmpty() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Empty
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ElementRules) GetNested() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Nested
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ElementRules) GetItem() *FieldRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var file_redact_v3_redact_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.FileOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         90102,
                Name:          "redact.v3.file_skip",
                Tag:           "varint,90102,opt,name=file_skip",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         54123,
                Name:          "redact.v3.service_skip",
                Tag:           "varint,54123,opt,name=service_skip",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         54124,
                Name:          "redact.v3.internal_service",
                Tag:           "varint,54124,opt,name=internal_service",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*uint32)(nil),
                Field:         54125,
                Name:          "redact.v3.internal_service_code",
                Tag:           "varint,54125,opt,name=internal_service_code",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*string)(nil),
                Field:         54126,
                Name:          "redact.v3.internal_service_err_message",
                Tag:           "bytes,54126,opt,name=internal_service_err_message",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         54123,
                Name:          "redact.v3.method_skip",
                Tag:           "varint,54123,opt,name=method_skip",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         54124,
                Name:          "redact.v3.internal_method",
                Tag:           "varint,54124,opt,name=internal_method",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*uint32)(nil),
                Field:         54125,
                Name:          "redact.v3.internal_method_code",
                Tag:           "varint,54125,opt,name=internal_method_code",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*string)(nil),
                Field:         54126,
                Name:          "redact.v3.internal_method_err_message",
                Tag:           "bytes,54126,opt,name=internal_method_err_message",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         54123,
                Name:          "redact.v3.nil",
                Tag:           "varint,54123,opt,name=nil",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         54124,
                Name:          "redact.v3.empty",
                Tag:           "varint,54124,opt,name=empty",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         54125,
                Name:          "redact.v3.ignored",
                Tag:           "varint,54125,opt,name=ignored",
                Filename:      "redact/v3/redact.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*FieldRules)(nil),
                Field:         54123,
                Name:          "redact.v3.value",
                Tag:           "bytes,54123,opt,name=value",
                Filename:      "redact/v3/redact.proto",
        },
}

// Extension fields to descriptorpb.FileOptions.
var (
        // FileSkip is used to skip generation of any redaction for proto file
        //
        // optional bool file_skip = 90102;
        E_FileSkip = &amp;file_redact_v3_redact_proto_extTypes[0]
)

// Extension fields to descriptorpb.ServiceOptions.
var (
        // ServiceSkip is used to skip the redaction in grpc service in the server
        //
        // optional bool service_skip = 54123;
        E_ServiceSkip = &amp;file_redact_v3_redact_proto_extTypes[1]
        // InternalService will make this service private and client will not be
        // able to receive any response for any of it's method, (unless skipped
        // explicitly) and will get PermissionDenied(7) error by default, to set
        // any other code set it in InternalServiceCode, it should be one of the
        // defined GRPC status code, and InternalServiceErrMessage for error
        // message, in which, one can use `%service%` or `%method%` tags to include
        // corresponding service name or method name, respectively.
        //
        // optional bool internal_service = 54124;
        E_InternalService = &amp;file_redact_v3_redact_proto_extTypes[2]
        // optional uint32 internal_service_code = 54125;
        E_InternalServiceCode = &amp;file_redact_v3_redact_proto_extTypes[3]
        // optional string internal_service_err_message = 54126;
        E_InternalServiceErrMessage = &amp;file_redact_v3_redact_proto_extTypes[4]
)

// Extension fields to descriptorpb.MethodOptions.
var (
        // MethodSkip is used to skip the redactions for this method in the grpc server
        //
        // optional bool method_skip = 54123;
        E_MethodSkip = &amp;file_redact_v3_redact_proto_extTypes[5]
        // InternalMethod, InternalMethodCode and InternalMethodErrMessage works same
        // as that of service level options: InternalService, InternalServiceCode and
        // InternalServiceErrMessage, but at Method level. All the validations and
        // functionalities are same for both. But the method level options will be used
        // whenever both are specified.
        //
        // optional bool internal_method = 54124;
        E_InternalMethod = &amp;file_redact_v3_redact_proto_extTypes[6]
        // optional uint32 internal_method_code = 54125;
        E_InternalMethodCode = &amp;file_redact_v3_redact_proto_extTypes[7]
        // optional string internal_method_err_message = 54126;
        E_InternalMethodErrMessage = &amp;file_redact_v3_redact_proto_extTypes[8]
)

// Extension fields to descriptorpb.MessageOptions.
var (
        // Nil will redact message to nil (can be override by field level, `empty` option)
        //
        // optional bool nil = 54123;
        E_Nil = &amp;file_redact_v3_redact_proto_extTypes[9]
        // Empty will redact message to it's empty object
        //
        // optional bool empty = 54124;
        E_Empty = &amp;file_redact_v3_redact_proto_extTypes[10]
        // Ignored skips generation of any redaction for this message.
        //
        // optional bool ignored = 54125;
        E_Ignored = &amp;file_redact_v3_redact_proto_extTypes[11]
)

// Extension fields to descriptorpb.FieldOptions.
var (
        // Redact: it redact the field with predefined defaults:
        //   - `0` for any number type
        //   - `"REDACTED"` for string type
        //   - `nil` for byte type
        //   - `0th value` for enum type
        //   - `nil` map for map type
        //   - `nil` for repeated field type
        //   - for message type, redaction is applied inside the message type
        //
        // bool redact = 54123;
        // Custom: specify the different values to be used for redaction on this field. By
        // default, if Custom value is not defined Redact should be true to apply redaction.
        // And if Custom value is to be assigned, one can skip the Redact field.
        //
        // optional redact.v3.FieldRules value = 54123;
        E_Value = &amp;file_redact_v3_redact_proto_extTypes[12]
)

var File_redact_v3_redact_proto protoreflect.FileDescriptor

var file_redact_v3_redact_proto_rawDesc = []byte{
        0x0a, 0x16, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x2f, 0x76, 0x33, 0x2f, 0x72, 0x65, 0x64, 0x61,
        0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x09, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74,
        0x2e, 0x76, 0x33, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x9c, 0x04, 0x0a, 0x0a, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x52,
        0x75, 0x6c, 0x65, 0x73, 0x12, 0x16, 0x0a, 0x05, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x02, 0x48, 0x00, 0x52, 0x05, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x12, 0x18, 0x0a, 0x06,
        0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x48, 0x00, 0x52, 0x06,
        0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x12, 0x16, 0x0a, 0x05, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x05, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x12, 0x16,
        0x0a, 0x05, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x48, 0x00, 0x52,
        0x05, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x12, 0x18, 0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32,
        0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32,
        0x12, 0x18, 0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04,
        0x48, 0x00, 0x52, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x12, 0x18, 0x0a, 0x06, 0x73, 0x69,
        0x6e, 0x74, 0x33, 0x32, 0x18, 0x08, 0x20, 0x01, 0x28, 0x11, 0x48, 0x00, 0x52, 0x06, 0x73, 0x69,
        0x6e, 0x74, 0x33, 0x32, 0x12, 0x18, 0x0a, 0x06, 0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x09,
        0x20, 0x01, 0x28, 0x12, 0x48, 0x00, 0x52, 0x06, 0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x12, 0x1a,
        0x0a, 0x07, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x07, 0x48,
        0x00, 0x52, 0x07, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x12, 0x1a, 0x0a, 0x07, 0x66, 0x69,
        0x78, 0x65, 0x64, 0x36, 0x34, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x06, 0x48, 0x00, 0x52, 0x07, 0x66,
        0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x12, 0x1c, 0x0a, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64,
        0x33, 0x32, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0f, 0x48, 0x00, 0x52, 0x08, 0x73, 0x66, 0x69, 0x78,
        0x65, 0x64, 0x33, 0x32, 0x12, 0x1c, 0x0a, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34,
        0x18, 0x0d, 0x20, 0x01, 0x28, 0x10, 0x48, 0x00, 0x52, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64,
        0x36, 0x34, 0x12, 0x14, 0x0a, 0x04, 0x62, 0x6f, 0x6f, 0x6c, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08,
        0x48, 0x00, 0x52, 0x04, 0x62, 0x6f, 0x6f, 0x6c, 0x12, 0x18, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69,
        0x6e, 0x67, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x06, 0x73, 0x74, 0x72, 0x69,
        0x6e, 0x67, 0x12, 0x16, 0x0a, 0x05, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x10, 0x20, 0x01, 0x28,
        0x0c, 0x48, 0x00, 0x52, 0x05, 0x62, 0x79, 0x74, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x04, 0x65, 0x6e,
        0x75, 0x6d, 0x18, 0x11, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x04, 0x65, 0x6e, 0x75, 0x6d,
        0x12, 0x33, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x13, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x17, 0x2e, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x2e, 0x76, 0x33, 0x2e, 0x4d, 0x65,
        0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x07, 0x6d, 0x65,
        0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x33, 0x0a, 0x07, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,
        0x18, 0x14, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x2e,
        0x76, 0x33, 0x2e, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48,
        0x00, 0x52, 0x07, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x42, 0x08, 0x0a, 0x06, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x73, 0x22, 0x60, 0x0a, 0x0c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52,
        0x75, 0x6c, 0x65, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6b, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x04, 0x73, 0x6b, 0x69, 0x70, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x70, 0x74,
        0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x10,
        0x0a, 0x03, 0x6e, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x6e, 0x69, 0x6c,
        0x12, 0x14, 0x0a, 0x05, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x05, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x22, 0x67, 0x0a, 0x0c, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e,
        0x74, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x16, 0x0a, 0x06,
        0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x6e, 0x65,
        0x73, 0x74, 0x65, 0x64, 0x12, 0x29, 0x0a, 0x04, 0x69, 0x74, 0x65, 0x6d, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x15, 0x2e, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x2e, 0x76, 0x33, 0x2e, 0x46,
        0x69, 0x65, 0x6c, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x04, 0x69, 0x74, 0x65, 0x6d, 0x3a,
        0x3b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x12, 0x1c, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x46,
        0x69, 0x6c, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xf6, 0xbf, 0x05, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x6b, 0x69, 0x70, 0x3a, 0x44, 0x0a, 0x0c,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x12, 0x1f, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xeb, 0xa6,
        0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x6b,
        0x69, 0x70, 0x3a, 0x4c, 0x0a, 0x10, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xec, 0xa6, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x0f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x3a, 0x55, 0x0a, 0x15, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xed, 0xa6, 0x03, 0x20, 0x01,
        0x28, 0x0d, 0x52, 0x13, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x3a, 0x62, 0x0a, 0x1c, 0x69, 0x6e, 0x74, 0x65, 0x72,
        0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x65, 0x72, 0x72, 0x5f,
        0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xee, 0xa6, 0x03, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x19, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x45, 0x72, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3a, 0x41, 0x0a, 0x0b, 0x6d,
        0x65, 0x74, 0x68, 0x6f, 0x64, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x12, 0x1e, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x74,
        0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xeb, 0xa6, 0x03, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x0a, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x53, 0x6b, 0x69, 0x70, 0x3a, 0x49,
        0x0a, 0x0f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f,
        0x64, 0x12, 0x1e, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0xec, 0xa6, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x69, 0x6e, 0x74, 0x65, 0x72,
        0x6e, 0x61, 0x6c, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x3a, 0x52, 0x0a, 0x14, 0x69, 0x6e, 0x74,
        0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x5f, 0x63, 0x6f, 0x64,
        0x65, 0x12, 0x1e, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0xed, 0xa6, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x69, 0x6e, 0x74, 0x65, 0x72,
        0x6e, 0x61, 0x6c, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x43, 0x6f, 0x64, 0x65, 0x3a, 0x5f, 0x0a,
        0x1b, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
        0x5f, 0x65, 0x72, 0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1e, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d,
        0x65, 0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xee, 0xa6, 0x03,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x18, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x4d, 0x65,
        0x74, 0x68, 0x6f, 0x64, 0x45, 0x72, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3a, 0x33,
        0x0a, 0x03, 0x6e, 0x69, 0x6c, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xeb, 0xa6, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03,
        0x6e, 0x69, 0x6c, 0x3a, 0x37, 0x0a, 0x05, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x1f, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d,
        0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xec, 0xa6,
        0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x3a, 0x3b, 0x0a, 0x07,
        0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,
        0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xed, 0xa6, 0x03, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x07, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x3a, 0x4c, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x12, 0x1d, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0xeb, 0xa6, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x72, 0x65, 0x64, 0x61,
        0x63, 0x74, 0x2e, 0x76, 0x33, 0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x42, 0x42, 0x5a, 0x40, 0x67, 0x69, 0x74, 0x68, 0x75,
        0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61, 0x72, 0x72, 0x61, 0x6b, 0x69, 0x73, 0x2d, 0x64, 0x69,
        0x67, 0x69, 0x74, 0x61, 0x6c, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e,
        0x2d, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x2f, 0x76, 0x33, 0x2f, 0x72, 0x65, 0x64, 0x61, 0x63,
        0x74, 0x2f, 0x76, 0x33, 0x3b, 0x72, 0x65, 0x64, 0x61, 0x63, 0x74, 0x62, 0x06, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x33,
}

var (
        file_redact_v3_redact_proto_rawDescOnce sync.Once
        file_redact_v3_redact_proto_rawDescData = file_redact_v3_redact_proto_rawDesc
)

func file_redact_v3_redact_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_redact_v3_redact_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_redact_v3_redact_proto_rawDescData = protoimpl.X.CompressGZIP(file_redact_v3_redact_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_redact_v3_redact_proto_rawDescData</span>
}

var file_redact_v3_redact_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_redact_v3_redact_proto_goTypes = []interface{}{
        (*FieldRules)(nil),                  // 0: redact.v3.FieldRules
        (*MessageRules)(nil),                // 1: redact.v3.MessageRules
        (*ElementRules)(nil),                // 2: redact.v3.ElementRules
        (*descriptorpb.FileOptions)(nil),    // 3: google.protobuf.FileOptions
        (*descriptorpb.ServiceOptions)(nil), // 4: google.protobuf.ServiceOptions
        (*descriptorpb.MethodOptions)(nil),  // 5: google.protobuf.MethodOptions
        (*descriptorpb.MessageOptions)(nil), // 6: google.protobuf.MessageOptions
        (*descriptorpb.FieldOptions)(nil),   // 7: google.protobuf.FieldOptions
}
var file_redact_v3_redact_proto_depIdxs = []int32{
        1,  // 0: redact.v3.FieldRules.message:type_name -&gt; redact.v3.MessageRules
        2,  // 1: redact.v3.FieldRules.element:type_name -&gt; redact.v3.ElementRules
        0,  // 2: redact.v3.ElementRules.item:type_name -&gt; redact.v3.FieldRules
        3,  // 3: redact.v3.file_skip:extendee -&gt; google.protobuf.FileOptions
        4,  // 4: redact.v3.service_skip:extendee -&gt; google.protobuf.ServiceOptions
        4,  // 5: redact.v3.internal_service:extendee -&gt; google.protobuf.ServiceOptions
        4,  // 6: redact.v3.internal_service_code:extendee -&gt; google.protobuf.ServiceOptions
        4,  // 7: redact.v3.internal_service_err_message:extendee -&gt; google.protobuf.ServiceOptions
        5,  // 8: redact.v3.method_skip:extendee -&gt; google.protobuf.MethodOptions
        5,  // 9: redact.v3.internal_method:extendee -&gt; google.protobuf.MethodOptions
        5,  // 10: redact.v3.internal_method_code:extendee -&gt; google.protobuf.MethodOptions
        5,  // 11: redact.v3.internal_method_err_message:extendee -&gt; google.protobuf.MethodOptions
        6,  // 12: redact.v3.nil:extendee -&gt; google.protobuf.MessageOptions
        6,  // 13: redact.v3.empty:extendee -&gt; google.protobuf.MessageOptions
        6,  // 14: redact.v3.ignored:extendee -&gt; google.protobuf.MessageOptions
        7,  // 15: redact.v3.value:extendee -&gt; google.protobuf.FieldOptions
        0,  // 16: redact.v3.value:type_name -&gt; redact.v3.FieldRules
        17, // [17:17] is the sub-list for method output_type
        17, // [17:17] is the sub-list for method input_type
        16, // [16:17] is the sub-list for extension type_name
        3,  // [3:16] is the sub-list for extension extendee
        0,  // [0:3] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_redact_v3_redact_proto_init() }</span>
func file_redact_v3_redact_proto_init() <span class="cov0" title="0">{
        if File_redact_v3_redact_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_redact_v3_redact_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FieldRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_redact_v3_redact_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*MessageRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_redact_v3_redact_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ElementRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">file_redact_v3_redact_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*FieldRules_Float)(nil),
                (*FieldRules_Double)(nil),
                (*FieldRules_Int32)(nil),
                (*FieldRules_Int64)(nil),
                (*FieldRules_Uint32)(nil),
                (*FieldRules_Uint64)(nil),
                (*FieldRules_Sint32)(nil),
                (*FieldRules_Sint64)(nil),
                (*FieldRules_Fixed32)(nil),
                (*FieldRules_Fixed64)(nil),
                (*FieldRules_Sfixed32)(nil),
                (*FieldRules_Sfixed64)(nil),
                (*FieldRules_Bool)(nil),
                (*FieldRules_String_)(nil),
                (*FieldRules_Bytes)(nil),
                (*FieldRules_Enum)(nil),
                (*FieldRules_Message)(nil),
                (*FieldRules_Element)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_redact_v3_redact_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 13,
                        NumServices:   0,
                },
                GoTypes:           file_redact_v3_redact_proto_goTypes,
                DependencyIndexes: file_redact_v3_redact_proto_depIdxs,
                MessageInfos:      file_redact_v3_redact_proto_msgTypes,
                ExtensionInfos:    file_redact_v3_redact_proto_extTypes,
        }.Build()
        File_redact_v3_redact_proto = out.File
        file_redact_v3_redact_proto_rawDesc = nil
        file_redact_v3_redact_proto_goTypes = nil
        file_redact_v3_redact_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        pgs "github.com/lyft/protoc-gen-star/v2"
)

// Note: must() and failWithInvalidType() have been moved to errors.go
// for better error handling and context

// RedactionDefaults returns the default value that can be used for the input
// pgs.Field for redaction. Predefined reduction defaults are:
//   - `0` for any number type
//   - `"REDACTED"` for string type
//   - `nil` for byte type
//   - `0th value` for enum type
//   - `nil` map for map type
//   - `nil` for repeated field type
//   - for message type, redaction is applied inside the message type
func RedactionDefaults(typ pgs.ProtoType, isRepeated bool) string <span class="cov10" title="51">{
        // isRepeated fields is for map or slice type fields
        if isRepeated </span><span class="cov4" title="5">{
                return "nil"
        }</span>
        <span class="cov9" title="46">switch typ </span>{
        case pgs.Int32T, pgs.Int64T,
                pgs.SInt32, pgs.SInt64,
                pgs.UInt32T, pgs.UInt64T,
                pgs.SFixed32, pgs.SFixed64,
                pgs.Fixed32T, pgs.Fixed64T,
                pgs.FloatT, pgs.DoubleT, pgs.EnumT:<span class="cov8" title="31">
                return "0"</span>
        case pgs.BoolT:<span class="cov3" title="3">
                return "false"</span>
        case pgs.StringT:<span class="cov4" title="5">
                return `"REDACTED"`</span>
        case pgs.BytesT, pgs.GroupT:<span class="cov4" title="5">
                return "nil"</span>
        case pgs.MessageT:<span class="cov2" title="2">
                return `-`</span>
        default:<span class="cov0" title="0"> // repeated and map
                return "nil"</span>
        }
}

// ToCustomRule return redact proto' field rules based on their type
func ToCustomRule(typ pgs.ProtoType, lab pgs.ProtoLabel) string <span class="cov8" title="23">{
        if lab == pgs.Repeated </span><span class="cov1" title="1">{
                return "(redact.custom).element.*"
        }</span>
        <span class="cov8" title="22">switch typ </span>{
        case pgs.FloatT:<span class="cov1" title="1">
                return "(redact.custom).float"</span>
        case pgs.DoubleT:<span class="cov1" title="1">
                return "(redact.custom).double"</span>
        case pgs.Int32T:<span class="cov2" title="2">
                return "(redact.custom).int32"</span>
        case pgs.Int64T:<span class="cov1" title="1">
                return "(redact.custom).int64"</span>
        case pgs.UInt32T:<span class="cov1" title="1">
                return "(redact.custom).uint32"</span>
        case pgs.UInt64T:<span class="cov1" title="1">
                return "(redact.custom).uint64"</span>
        case pgs.SInt32:<span class="cov1" title="1">
                return "(redact.custom).sint32"</span>
        case pgs.SInt64:<span class="cov1" title="1">
                return "(redact.custom).sint64"</span>
        case pgs.Fixed32T:<span class="cov1" title="1">
                return "(redact.custom).fixed32"</span>
        case pgs.Fixed64T:<span class="cov1" title="1">
                return "(redact.custom).fixed64"</span>
        case pgs.SFixed32:<span class="cov1" title="1">
                return "(redact.custom).sfixed32"</span>
        case pgs.SFixed64:<span class="cov1" title="1">
                return "(redact.custom).sfixed64"</span>
        case pgs.BoolT:<span class="cov1" title="1">
                return "(redact.custom).bool"</span>
        case pgs.StringT:<span class="cov2" title="2">
                return "(redact.custom).string"</span>
        case pgs.BytesT:<span class="cov2" title="2">
                return "(redact.custom).bytes"</span>
        case pgs.EnumT:<span class="cov1" title="1">
                return "(redact.custom).enum"</span>
        case pgs.MessageT:<span class="cov2" title="2">
                return "(redact.custom).message.*"</span>
        default:<span class="cov1" title="1">
                return "(redact.redact)"</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
