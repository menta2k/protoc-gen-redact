package main

import (
	"os"
	"path/filepath"
	"text/template"

	pgs "github.com/lyft/protoc-gen-star/v2"
	pgsGo "github.com/lyft/protoc-gen-star/v2/lang/go"
)

// Redactor returns the implementation of the protoc-gen-redact plugin
// to generate redaction file
func Redactor() pgs.Module { return &Module{ModuleBase: &pgs.ModuleBase{}} }

// Module implements the pgs.Module interface for protoc-gen-redact plugin
type Module struct {
	*pgs.ModuleBase
	ctx  pgsGo.Context
	tmpl *template.Template
}

// Name returns the name of this protoc-gen-star module
func (*Module) Name() string { return "redactor" }

// InitContext satisfies the pgs.Module interface and helps build the module
func (m *Module) InitContext(c pgs.BuildContext) {
	// Add panic recovery for initialization
	defer func() {
		if r := recover(); r != nil {
			m.Failf("Panic during module initialization: %v", r)
		}
	}()

	m.ModuleBase.InitContext(c)
	m.ctx = pgsGo.InitContext(c.Parameters())

	// Validate context
	if m.ctx == nil {
		m.Fail("Failed to initialize Go context")
		return
	}

	// Check for custom template file parameter
	templateFile := c.Parameters().Str("template_file")

	tpl := template.New("redact").Funcs(map[string]interface{}{
		"package": m.ctx.PackageName,
		"name":    m.ctx.Name,
	})

	var parsedTpl *template.Template
	var err error

	if templateFile != "" {
		// Load template from external file
		m.Debug("Loading template from file: " + templateFile)
		parsedTpl, err = m.loadTemplateFromFile(tpl, templateFile)
		if err != nil {
			m.Failf("Failed to load template from file %s: %v", templateFile, err)
			return
		}
		m.Debug("Successfully loaded external template")
	} else {
		// Use embedded template
		m.Debug("Using embedded template")
		parsedTpl, err = tpl.Parse(redactTpl)
		if err != nil {
			m.Failf("Failed to parse embedded template: %v", err)
			return
		}
	}

	m.tmpl = parsedTpl
	m.Debug("Module initialized successfully")
}

// Execute satisfies the pgs.Module interface & generates the redactor file
// for the targeted files
func (m *Module) Execute(targets map[string]pgs.File, _ map[string]pgs.Package) []pgs.Artifact {
	// process all the target files
	for _, file := range targets {
		m.Process(file)
	}
	return m.Artifacts()
}

// loadTemplateFromFile loads a template from an external file
func (m *Module) loadTemplateFromFile(tpl *template.Template, templatePath string) (*template.Template, error) {
	// Validate the file path
	if templatePath == "" {
		return nil, ErrorContext{
			Location: "template_file parameter",
			Reason:   "template file path is empty",
		}
	}

	// Resolve absolute path
	absPath, err := filepath.Abs(templatePath)
	if err != nil {
		return nil, ErrorContext{
			Location: "template_file: " + templatePath,
			Reason:   "failed to resolve absolute path: " + err.Error(),
		}
	}

	// Check if file exists
	fileInfo, err := os.Stat(absPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, ErrorContext{
				Location: "template_file: " + absPath,
				Reason:   "file does not exist",
			}
		}
		return nil, ErrorContext{
			Location: "template_file: " + absPath,
			Reason:   "failed to stat file: " + err.Error(),
		}
	}

	// Check if it's a regular file
	if !fileInfo.Mode().IsRegular() {
		return nil, ErrorContext{
			Location: "template_file: " + absPath,
			Reason:   "path is not a regular file",
		}
	}

	// Check file size (limit to 10MB for safety)
	const maxTemplateSize = 10 * 1024 * 1024 // 10MB
	if fileInfo.Size() > maxTemplateSize {
		return nil, ErrorContext{
			Location: "template_file: " + absPath,
			Reason:   "template file is too large (max 10MB)",
		}
	}

	// Read the template file
	templateContent, err := os.ReadFile(absPath)
	if err != nil {
		return nil, ErrorContext{
			Location: "template_file: " + absPath,
			Reason:   "failed to read file: " + err.Error(),
		}
	}

	// Parse the template
	parsedTpl, err := tpl.Parse(string(templateContent))
	if err != nil {
		return nil, ErrorContext{
			Location: "template_file: " + absPath,
			Reason:   "failed to parse template: " + err.Error(),
		}
	}

	m.Debug("Template loaded successfully from: " + absPath)
	return parsedTpl, nil
}

const redactTpl = `{{ $data := . }}
// Code generated by protoc-gen-redact. DO NOT EDIT.
// source: {{ $data.Source }}

package {{ $data.Package }}

import (
	{{- range $alias, $path := $data.Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	{{- range $name := $data.References }}
	_ {{ $name }}
	{{- end }}
)

{{ range $srv := $data.Services }}
	{{- if $srv.Skip }}
		// Redacted server wrapper for {{ $srv.Name }} is skipped
		var RegisterRedacted{{ $srv.Name }} = Register{{ $srv.Name }}
	{{- else }}
		// RegisterRedacted{{ $srv.Name }} wraps the {{ $srv.Name }} with the redacted server and registers the service in GRPC
		func RegisterRedacted{{ $srv.Name }}(s grpc.ServiceRegistrar, srv {{ $srv.Name }}, bypass redact.Bypass) {
			Register{{ $srv.Name }}(s, Redacted{{ $srv.Name }}(srv, bypass))
		}

		func Redacted{{ $srv.Name }}(srv {{ $srv.Name }}, bypass redact.Bypass) {{ $srv.Name }} {
			if bypass == nil {
				bypass = redact.Falsy
			}
			return &redacted{{ $srv.Name }}{srv: srv, bypass: bypass}
		}

		type redacted{{ $srv.Name }} struct {
			Unsafe{{ $srv.Name }}
			srv    {{ $srv.Name }}
			bypass redact.Bypass
		}

		{{ range $meth := $srv.Methods }}
			// {{ $meth.Name }} is the redacted wrapper for the actual {{ $srv.Name }}.{{ $meth.Name }} method
			{{- if and $meth.ClientStreaming $meth.ServerStreaming }}
				// Bidirectional streaming
				func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(stream grpc.BidiStreamingServer[{{ $meth.Input }}, {{ $meth.Output.WithAlias }}]) error {
					{{- if $meth.Skip }}
						// Redaction skipped
						return s.srv.{{ $meth.Name }}(stream)
					{{- else }}
						// Note: Redaction for bidirectional streaming is not fully implemented
						// Streaming methods pass through without redaction
						return s.srv.{{ $meth.Name }}(stream)
					{{- end }}
				}
			{{- else if $meth.ClientStreaming }}
				// Client streaming
				func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(stream grpc.ClientStreamingServer[{{ $meth.Input }}, {{ $meth.Output.WithAlias }}]) error {
					{{- if $meth.Skip }}
						// Redaction skipped
						return s.srv.{{ $meth.Name }}(stream)
					{{- else }}
						// Note: Redaction for client streaming is not fully implemented
						// Streaming methods pass through without redaction
						return s.srv.{{ $meth.Name }}(stream)
					{{- end }}
				}
			{{- else if $meth.ServerStreaming }}
				// Server streaming
				func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(in *{{ $meth.Input }}, stream grpc.ServerStreamingServer[{{ $meth.Output.WithAlias }}]) error {
					{{- if $meth.Skip }}
						// Redaction skipped
						return s.srv.{{ $meth.Name }}(in, stream)
					{{- else }}
						// Note: Redaction for server streaming is not fully implemented
						// Streaming methods pass through without redaction
						return s.srv.{{ $meth.Name }}(in, stream)
					{{- end }}
				}
			{{- else }}
				// Unary RPC
				func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(ctx context.Context, in *{{ $meth.Input }}) (*{{ $meth.Output.WithAlias }}, error) {
					{{- if $meth.Skip }}
						// Redaction skipped
						return s.srv.{{ $meth.Name }}(ctx, in)
					{{- else if $meth.Internal }}
						if s.bypass.CheckInternal(ctx) {
							return s.srv.{{ $meth.Name }}(ctx, in)
						}
						return nil, status.Error(codes.{{ $meth.StatusCode }}, {{ $meth.ErrMessage }})
					{{- else }}
						res, err := s.srv.{{ $meth.Name }}(ctx, in)
						if !s.bypass.CheckInternal(ctx) {
							{{- if $meth.Output.ToNil }}
								// Response message is set to nil, ignoring all field level rules
								res = nil
							{{- else if $meth.Output.ToEmpty }}
								// Response message is set to empty, ignoring all field level rules
								res = &{{ $meth.Output.WithAlias }}{}
							{{- else if $meth.Output.Ignore  }}
								// Response message is set to be ignored from any redaction
							{{- else }}
								// Apply redaction to the response
								redact.Apply(res)
							{{- end }}
						}
						return res, err
					{{- end }}
				}
			{{- end }}
		{{ end }}
	{{ end }}
{{ end }}

{{ range $msg := $data.Messages }}
	// Redact method implementation for {{ $msg.Name }}
	func (x *{{ $msg.Name }}) Redact() string {
		{{- if $msg.Ignore }}
			// Ignoring message
		{{- else if $msg.ToEmpty }}
			// Message will be set to empty, ignoring all field level rules
		{{- else if $msg.ToNil }}
			// Message will be set to nil, ignoring all field level rules
		{{- else }}
			if x == nil { return "" }
			{{- range $field := $msg.Fields }}
				{{ if $field.Redact }}
					// Redacting field: {{ $field.Name }}
					{{- if $field.Iterate }}
						{{- if $field.NestedEmbedCall }}
							for k := range x.{{ $field.Name }} {
								redact.Apply(x.{{$field.Name}}[k])
							}
						{{- else if $field.EmbedSkip }}
							// {{$field.Name}} redaction is skipped
                        {{- else }}
							for k := range x.{{ $field.Name }} {
								x.{{ $field.Name }}[k] = {{ $field.RedactionValue }}
							}
						{{- end }}
                    {{- else if $field.IsMessage }}
						{{- if $field.NestedEmbedCall }}
							redact.Apply(x.{{$field.Name}})
						{{- else if $field.EmbedSkip }}
							// {{$field.Name}} redaction is skipped
                        {{- else }}
							x.{{ $field.Name }} = {{ $field.RedactionValue }}
						{{- end }}
                    {{- else }}
						{{- if $field.IsOptional }}
							{{- if eq $field.FieldGoType "string" }}
								{{ $field.Name }}Tmp := {{ $field.RedactionValue }}
								x.{{ $field.Name }} = &{{ $field.Name }}Tmp
							{{- else }}
								{{ $field.Name }}Tmp := {{ $field.FieldGoType }}({{ $field.RedactionValue }})
								x.{{ $field.Name }} = &{{ $field.Name }}Tmp
							{{- end }}
						{{- else }}
							x.{{ $field.Name }} = {{ $field.RedactionValue }}
						{{- end }}
					{{- end }}
				{{- else }}
					// Safe field: {{ $field.Name }}
				{{- end }}
			{{- end }}
		{{- end }}
    return x.String()
	}
{{ end }}
`
