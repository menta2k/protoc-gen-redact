{{ $data := . }}
// Code generated by protoc-gen-redact. DO NOT EDIT.
// source: {{ $data.Source }}

package {{ $data.Package }}

import (
	{{- range $alias, $path := $data.Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	{{- range $name := $data.References }}
	_ {{ $name }}
	{{- end }}
)

{{ range $srv := $data.Services }}
	{{- if $srv.Skip }}
		// Redacted server wrapper for {{ $srv.Name }} is skipped
		var RegisterRedacted{{ $srv.Name }} = Register{{ $srv.Name }}
	{{- else }}
		// RegisterRedacted{{ $srv.Name }} wraps the {{ $srv.Name }} with the redacted server and registers the service in GRPC
		func RegisterRedacted{{ $srv.Name }}(s grpc.ServiceRegistrar, srv {{ $srv.Name }}, bypass redact.Bypass) {
			Register{{ $srv.Name }}(s, Redacted{{ $srv.Name }}(srv, bypass))
		}

		func Redacted{{ $srv.Name }}(srv {{ $srv.Name }}, bypass redact.Bypass) {{ $srv.Name }} {
			if bypass == nil {
				bypass = redact.Falsy
			}
			return &redacted{{ $srv.Name }}{srv: srv, bypass: bypass}
		}

		type redacted{{ $srv.Name }} struct {
			Unsafe{{ $srv.Name }}
			srv    {{ $srv.Name }}
			bypass redact.Bypass
		}

		{{ range $meth := $srv.Methods }}
			// {{ $meth.Name }} is the redacted wrapper for the actual {{ $srv.Name }}.{{ $meth.Name }} method
			{{- if and $meth.ClientStreaming $meth.ServerStreaming }}
				// Bidirectional streaming
				func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(stream grpc.BidiStreamingServer[{{ $meth.Input }}, {{ $meth.Output.WithAlias }}]) error {
					{{- if $meth.Skip }}
						// Redaction skipped
						return s.srv.{{ $meth.Name }}(stream)
					{{- else }}
						// Note: Redaction for bidirectional streaming is not fully implemented
						// Streaming methods pass through without redaction
						return s.srv.{{ $meth.Name }}(stream)
					{{- end }}
				}
			{{- else if $meth.ClientStreaming }}
				// Client streaming
				func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(stream grpc.ClientStreamingServer[{{ $meth.Input }}, {{ $meth.Output.WithAlias }}]) error {
					{{- if $meth.Skip }}
						// Redaction skipped
						return s.srv.{{ $meth.Name }}(stream)
					{{- else }}
						// Note: Redaction for client streaming is not fully implemented
						// Streaming methods pass through without redaction
						return s.srv.{{ $meth.Name }}(stream)
					{{- end }}
				}
			{{- else if $meth.ServerStreaming }}
				// Server streaming
				func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(in *{{ $meth.Input }}, stream grpc.ServerStreamingServer[{{ $meth.Output.WithAlias }}]) error {
					{{- if $meth.Skip }}
						// Redaction skipped
						return s.srv.{{ $meth.Name }}(in, stream)
					{{- else }}
						// Note: Redaction for server streaming is not fully implemented
						// Streaming methods pass through without redaction
						return s.srv.{{ $meth.Name }}(in, stream)
					{{- end }}
				}
			{{- else }}
				// Unary RPC
				func (s *redacted{{ $srv.Name }}) {{ $meth.Name }}(ctx context.Context, in *{{ $meth.Input }}) (*{{ $meth.Output.WithAlias }}, error) {
					{{- if $meth.Skip }}
						// Redaction skipped
						return s.srv.{{ $meth.Name }}(ctx, in)
					{{- else if $meth.Internal }}
						if s.bypass.CheckInternal(ctx) {
							return s.srv.{{ $meth.Name }}(ctx, in)
						}
						return nil, status.Error(codes.{{ $meth.StatusCode }}, {{ $meth.ErrMessage }})
					{{- else }}
						res, err := s.srv.{{ $meth.Name }}(ctx, in)
						if !s.bypass.CheckInternal(ctx) {
							{{- if $meth.Output.ToNil }}
								// Response message is set to nil, ignoring all field level rules
								res = nil
							{{- else if $meth.Output.ToEmpty }}
								// Response message is set to empty, ignoring all field level rules
								res = &{{ $meth.Output.WithAlias }}{}
							{{- else if $meth.Output.Ignore  }}
								// Response message is set to be ignored from any redaction
							{{- else }}
								// Apply redaction to the response
								redact.Apply(res)
							{{- end }}
						}
						return res, err
					{{- end }}
				}
			{{- end }}
		{{ end }}
	{{ end }}
{{ end }}

{{ range $msg := $data.Messages }}
	// Redact method implementation for {{ $msg.Name }}
	func (x *{{ $msg.Name }}) Redact() string {
		{{- if $msg.Ignore }}
			// Ignoring message
		{{- else if $msg.ToEmpty }}
			// Message will be set to empty, ignoring all field level rules
		{{- else if $msg.ToNil }}
			// Message will be set to nil, ignoring all field level rules
		{{- else }}
			if x == nil { return "" }
			{{- range $field := $msg.Fields }}
				{{ if $field.Redact }}
					// Redacting field: {{ $field.Name }}
					{{- if $field.Iterate }}
						{{- if $field.NestedEmbedCall }}
							for k := range x.{{ $field.Name }} {
								redact.Apply(x.{{$field.Name}}[k])
							}
						{{- else if $field.EmbedSkip }}
							// {{$field.Name}} redaction is skipped
                        {{- else }}
							for k := range x.{{ $field.Name }} {
								x.{{ $field.Name }}[k] = {{ $field.RedactionValue }}
							}
						{{- end }}
                    {{- else if $field.IsMessage }}
						{{- if $field.NestedEmbedCall }}
							redact.Apply(x.{{$field.Name}})
						{{- else if $field.EmbedSkip }}
							// {{$field.Name}} redaction is skipped
                        {{- else }}
							x.{{ $field.Name }} = {{ $field.RedactionValue }}
						{{- end }}
                    {{- else }}
						{{- if $field.IsOptional }}
							{{- if eq $field.FieldGoType "string" }}
								{{ $field.Name }}Tmp := {{ $field.RedactionValue }}
								x.{{ $field.Name }} = &{{ $field.Name }}Tmp
							{{- else }}
								{{ $field.Name }}Tmp := {{ $field.FieldGoType }}({{ $field.RedactionValue }})
								x.{{ $field.Name }} = &{{ $field.Name }}Tmp
							{{- end }}
						{{- else }}
							x.{{ $field.Name }} = {{ $field.RedactionValue }}
						{{- end }}
					{{- end }}
				{{- else }}
					// Safe field: {{ $field.Name }}
				{{- end }}
			{{- end }}
		{{- end }}
    return x.String()
	}
{{ end }}
