package main

import (
	"os"
	"os/exec"
	"path/filepath"
	"testing"
	"text/template"

	pgs "github.com/lyft/protoc-gen-star/v2"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestExternalTemplateLoading tests loading templates from external files
func TestExternalTemplateLoading(t *testing.T) {
	// Get current working directory
	currentDir, err := os.Getwd()
	require.NoError(t, err)

	testDir := filepath.Join(currentDir, "testdata", "integration")
	protoFile := filepath.Join(testDir, "test.proto")

	t.Run("use_external_template", func(t *testing.T) {
		// Build the plugin
		buildCmd := exec.Command("go", "build", "-o", "protoc-gen-redact", ".")
		buildOutput, err := buildCmd.CombinedOutput()
		if err != nil {
			t.Logf("build output: %s", string(buildOutput))
		}
		require.NoError(t, err, "Should build protoc-gen-redact plugin")

		pluginPath := filepath.Join(currentDir, "protoc-gen-redact")
		require.FileExists(t, pluginPath, "Plugin binary should exist")

		templatePath := filepath.Join(currentDir, "examples", "custom-template.tmpl")
		require.FileExists(t, templatePath, "Example template should exist")

		// Generate code using external template
		cmd := exec.Command("protoc",
			"--experimental_allow_proto3_optional",
			"--plugin=protoc-gen-redact="+pluginPath,
			"--redact_out="+currentDir,
			"--redact_opt=template_file="+templatePath+",paths=source_relative",
			"-I="+currentDir,
			protoFile,
		)

		output, err := cmd.CombinedOutput()
		if err != nil {
			t.Logf("protoc output: %s", string(output))
		}
		require.NoError(t, err, "Should generate code with external template")

		// Verify generated file exists
		redactFile := filepath.Join(testDir, "test.pb.redact.go")
		require.FileExists(t, redactFile, "Generated redaction file should exist")

		// Verify file contains expected content
		content, err := os.ReadFile(redactFile)
		require.NoError(t, err)

		contentStr := string(content)
		assert.Contains(t, contentStr, "package testdata", "Should have correct package")
		assert.Contains(t, contentStr, "Code generated by protoc-gen-redact", "Should have generated comment")
		assert.Contains(t, contentStr, "func (x *TestMessage) Redact()", "Should have Redact method")
	})

	t.Run("nonexistent_template_file", func(t *testing.T) {
		pluginPath := filepath.Join(currentDir, "protoc-gen-redact")

		// Try to use nonexistent template
		cmd := exec.Command("protoc",
			"--experimental_allow_proto3_optional",
			"--plugin=protoc-gen-redact="+pluginPath,
			"--redact_out="+currentDir,
			"--redact_opt=template_file=/nonexistent/template.tmpl,paths=source_relative",
			"-I="+currentDir,
			protoFile,
		)

		output, err := cmd.CombinedOutput()
		outputStr := string(output)

		require.Error(t, err, "Should fail with nonexistent template")
		assert.Contains(t, outputStr, "file does not exist", "Should report file not found")
	})

	t.Run("invalid_template_syntax", func(t *testing.T) {
		// Create a temporary invalid template
		tmpDir := t.TempDir()
		invalidTemplate := filepath.Join(tmpDir, "invalid.tmpl")
		err := os.WriteFile(invalidTemplate, []byte("{{ invalid syntax"), 0644)
		require.NoError(t, err)

		pluginPath := filepath.Join(currentDir, "protoc-gen-redact")

		// Try to use invalid template
		cmd := exec.Command("protoc",
			"--experimental_allow_proto3_optional",
			"--plugin=protoc-gen-redact="+pluginPath,
			"--redact_out="+currentDir,
			"--redact_opt=template_file="+invalidTemplate+",paths=source_relative",
			"-I="+currentDir,
			protoFile,
		)

		output, err := cmd.CombinedOutput()
		outputStr := string(output)

		require.Error(t, err, "Should fail with invalid template")
		assert.Contains(t, outputStr, "failed to parse template", "Should report parse error")
	})

	t.Run("template_too_large", func(t *testing.T) {
		// Create a template that's too large (> 10MB)
		tmpDir := t.TempDir()
		largeTemplate := filepath.Join(tmpDir, "large.tmpl")

		// Create a 11MB file
		largeContent := make([]byte, 11*1024*1024)
		for i := range largeContent {
			largeContent[i] = 'a'
		}
		err := os.WriteFile(largeTemplate, largeContent, 0644)
		require.NoError(t, err)

		pluginPath := filepath.Join(currentDir, "protoc-gen-redact")

		// Try to use large template
		cmd := exec.Command("protoc",
			"--experimental_allow_proto3_optional",
			"--plugin=protoc-gen-redact="+pluginPath,
			"--redact_out="+currentDir,
			"--redact_opt=template_file="+largeTemplate+",paths=source_relative",
			"-I="+currentDir,
			protoFile,
		)

		output, err := cmd.CombinedOutput()
		outputStr := string(output)

		require.Error(t, err, "Should fail with oversized template")
		assert.Contains(t, outputStr, "too large", "Should report size error")
	})

	t.Run("relative_path_template", func(t *testing.T) {
		// Test with relative path
		pluginPath := "./protoc-gen-redact"
		templatePath := "./examples/custom-template.tmpl"

		cmd := exec.Command("protoc",
			"--experimental_allow_proto3_optional",
			"--plugin=protoc-gen-redact="+pluginPath,
			"--redact_out="+currentDir,
			"--redact_opt=template_file="+templatePath+",paths=source_relative",
			"-I="+currentDir,
			protoFile,
		)
		cmd.Dir = currentDir

		output, err := cmd.CombinedOutput()
		if err != nil {
			t.Logf("protoc output: %s", string(output))
		}
		require.NoError(t, err, "Should work with relative paths")
	})
}

// TestTemplateParameterValidation tests template parameter validation
func TestTemplateParameterValidation(t *testing.T) {
	m := &Module{ModuleBase: &pgs.ModuleBase{}}

	tests := []struct {
		name        string
		setupFunc   func() string // returns template path
		shouldError bool
		errorMsg    string
	}{
		{
			name: "empty_path",
			setupFunc: func() string {
				return ""
			},
			shouldError: true,
			errorMsg:    "empty",
		},
		{
			name: "directory_not_file",
			setupFunc: func() string {
				tmpDir := t.TempDir()
				return tmpDir
			},
			shouldError: true,
			errorMsg:    "not a regular file",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			templatePath := tt.setupFunc()

			tpl := &template.Template{}
			_, err := m.loadTemplateFromFile(tpl, templatePath)

			if tt.shouldError {
				require.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				require.NoError(t, err)
			}
		})
	}
}
